---
title: Цитирование в C#
date: "2022-02-11 19:00:00 +0300"
id: csharp-quotation
excerpt: "Использование деревьев выражений для символического вычисления производных функций."
mathjax: true
---

В этом году весенний DotNext перенесли на неопределённый срок. А я к нему готовлюсь.

В рамках доклада про разные интересности в C#, разработал небольшую библиотеку для генерации производных функций.

### Задача

Саму задачу я встретил, решая упражнения из великой книги [Структура и Интерпретация Компьютерных Программ](https://ru.wikipedia.org/wiki/Структура_и_интерпретация_компьютерных_программ#:~:text=«Структу́ра%20и%20интерпрета́ция%20компью́терных%20програ́мм,технологического%20института%20в%201985%20году.). Её обычно называют SICP (читается *сик-пи*) — это аббревиатура названия книги на английском.

Раздел 2.3 посвящён *цитированию* в LISP и *символическим вычислениям*.

Обычные — несимволические — вычисления сводятся к тому, что мы считаем какие-то величины с помощью арифметических операций. Например, если я попрошу вас вычислить производную функции
$x^2$ в точке $x = 17$, вы можете сделать это по формуле:

$$
(x^2)' = \frac{(x+dx)^2-x^2}{dx}
$$

при каком-нибудь не очень большом значении $dx$:

$$
\frac{(17+0.0001)^2-17^2}{0.0001} = 34.0001000001
$$

Выбирая значение $dx$, мы можем вычислить производную с хорошей точностью. Символические же вычисления позволяют нам применить правила выведения производных и вычислить значение абсолютно точно.

$$
(x^2)' = 2x
$$

При $x = 17$ значение производной будет равно ровно $34$.

### Детали

SICP предлагает решать задачу вычисляения производной с помощью *цитирования*. По английски этот механизм называется *quotation*.

Если мы вводим в интепретатор LISP любое выражение:

```scheme
; (+ 3 4)
7
```

он его сразу вычисляет. Но если мы предваряем его *кавычкой* (*quote*), LISP сохраняет его в виде списка, не вычисляя:

```scheme
; '(+ 3 4)
(+ 3 4)
```

Таким образом, мы можем получить корректное выражение на LISP и обработать его, как любой другой список, в частности преобразовать по правилам вычисления производной.

Кажется, что функция преобразования производной может быть сложной. В целом, да. Но хорошие результаты даёт уже достаточно простая функция:

```scheme
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (make-sum a1 a2) (list '+ a1 a2))
(define (make-product m1 m2) (list '* m1 m2))
(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))
(define (addend s) (cadr s))
(define (augend s) (caddr s))
(define (product? x)
  (and (pair? x) (eq? (car x) '*)))
(define (multiplier p) (cadr p))
(define (multiplicand p) (caddr p))

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        (else
         (error "Unknown expression type"))))
```