---
title: Скрещиваем T4 и NuGet
date: "2018-05-15 15:00:00 +0300"
id: t4-and-nuget
excerpt: Как сделать NuGet-пакет, содержащий только шаблоны T4.
---

## T4

Text Template Transofmaton Toolkit можно перевести на русский, как &laquo;инструментарий для преобразования текстовых шаблонов&raquo;. Название объясняет не очень многое,
зато красиво сокращается до TTTT. Традиционно вместо этой аббревиатуры пишут просто T4.

T4&nbsp;&mdash; это набор средств для *генерации кода*. В разработке иногда возникают ситуации, когда проще написать не программу, а программу
для её генерации. Например, если кода будет много, а его структура будет простой.

При сборке проекта Visual Studio (MSBuild) сначала генерирует из шаблонов файлы **.cs**, а затем компилирует их вместе с кодом, написанным вручную.

Шаблоны хранятся в файлах с расширинем **.tt**. Языком разработки могут быть как C#, так и VisualBASIC.NET. Код шаблона содержит управляющие инструкции, то есть
условия и циклы, и *текстовые вставки*, из которых в конечном итоге собирается программа. Похожим образом выглядит код на PHP или страница ASPX, только результатом
работы кодогенератора является C#, а не HTML.

## NuGet

NuGet&nbsp;&mdash; пакетный менеджер для .NET проектов. Пакеты упрощают подключение внешний библиотек, и решают большое количество сопуствующих проблем,
например, проблему несовместимости версий. Основной частью пакета обычно является исполняемый код, но иногда в него могут входить и ресурсы.

## Проблема

Обычно кодогенерация решает локальные проблемы проекта, поэтому необходимость повторно использовать шаблоны T4 возникает нечасто. Одним из случаев можно
считать задачу генерации моделей для приложений Web API.

Предположим, что наш сервис позволяет регистрировать пользователей и изменять их данные. Пусть это будут:

1. Целочисленный идентификатор.
1. Адрес электронной почты, а по совместительству&nbsp;&mdash; логин.
1. Пароль.
1. Имя.
1. Фамилия.

Мы, кажется, могли бы использовать в качестве модели простой класс:

**UserModel.cs**
```c#
public class UserModel
{
    public int Id { get; set;}

    public string Email { get; set; }

    public string Password { get; set; }

    public string GivenNames { get; set; }

    public string FamilyName { get; set; }
}
```

К сожалению, в разных сценариях нам нужны разные поля.

1. При создании пользователя нам известны адрес электронной почты, пароль, имя и фамилия. Идентификатор не нужен, поскольку его генерирует сервер.
1. При чтении пользователя мы не можем вернуть пароль, поскольку мы храним не сам пароль, а его хеш.
1. При изменении мы должны использовать два метода. Первый позволяет менять имя и фамилию, второй&nbsp;&mdash; пароль. Поле `Email` изменить нельзя.

В идеале нам потребуется четыре модели:

`POST /users/` \
**UserCreateModel.cs**
```c#
public class UserCreateModel
{
    public string Email { get; set; }

    public string Password { get; set; }

    public string GivenNames { get; set; }

    public string FamilyName { get; set; }
}
```

`### GET /users/{userId}` \
**UserReadModel.cs**
```c#
public class UserReadModel
{
    public int Id { get; set; }

    public string Email { get; set; }

    public string GivenNames { get; set; }

    public string FamilyName { get; set; }
}
```

`PUT /users/{userId}` \
**UserUpdateModel.cs**
```c#
public class UserUpdateModel
{
    public string GivenNames { get; set; }

    public string FamilyName { get; set; }
}
```

`PUT /users/{userId}/password` \
**UserPasswordUpdateModel**
```c#
public class UserPasswordUpdateModel
{
    public string OldPassword { get; set; }

    public string NewPassword { get; set; }
}
```

Четыре простых класса вместо одного&nbsp;&mdash; это признак грядущих проблем. Что, если мы захотим переимновать поле, и забудем это сделать
в одном из классов? Кажется, надо организовать эти классы в одну иерархию. К сожалению, иерархию сделать не удастся, потому что поля распределяются по классам
вне всякой закономерности.

Как раз в этом случае нам может помочь кодогенерация моделей из одного источника, например, из файла **.csv**:

| Type |   Name    |Create|Read|Update|PasswordUpdate|
|-----:|:----------|:----:|:--:|:----:|:------------:|
|   int|Id         |      |  + |      |              |
|string|Email      |   +  |  + |      |              |
|string|GivenNames |   +  |  + |   +  |              |
|string|FamilyName |   +  |  + |   +  |              |
|string|Password   |   +  |    |      |              |
|string|OldPassword|      |    |      |       +      |
|string|NewPassword|      |    |      |       +      |

Возможно ли это? Попробуем разобраться.

## Шаг I: включение шаблонов

Наше решение должно состоять из двух файлов кодогенерации. Один распространяется в составе пакета и умеет генерировать код из файла **.csv**,
а второй вызывает методы первого с конкретными параметрами:

**Models.ttinclude**
```
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#+
public void PrintModels(string csvFilename, string classNameTemplate)
{
    . . .
}
#>
```

**Models.tt**
```
<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ include file="Models.ttinclude" #>
<#@ output extension=".cs" #>
using System;
using Taxys.Geometry;

namespace Foo.Bar
{
<#
PrintModels(Host.ResolvePath("User.csv", "{File}{Column}Model"));
#>
}
```

Директива [`@include`](https://docs.microsoft.com/ru-ru/visualstudio/modeling/t4-include-directive) включает содержимое одного шаблона в другой.
Visual Studio генерирует код для каждого файла с расширением **.tt**, поэтому расширение включаемого шаблона надо изменить&nbsp;&mdash;
для него код генерировать не нужно. Вместо **.tt** обычно используют **.t4** или **.ttinclude**.

В шаблоне **Models.ttinclude** (включаемом) реализуем метод `PrintModels`. Вызовем его из шаблона **Models.tt** (включаемого) и передадим в параметрах
путь к файлу моделей, и шаблон имени класса. Шаблон `"{File}{Column}Modle"` означает, что имя класса строится из имени файла, имени колонки и слова **Model**.

Файл **User.csv** и колонка **Create** дадут класс `UserCreateModel`.

## Шаг II: создание пакета NuGet с шаблоном **.ttinclude**

Создадим пустую папку, где будут размещаться исходные коды пакета, скопируем в неё **Models.ttinclude**. [Скачаем утилиту **nuget.exe**](https://www.nuget.org/downloads).
Создадим файл **Models.spec**.

```xml
<?xml version="1.0" encoding="utf-8"?>
<package xmlns="http://schemas.microsoft.com/packaging/2011/08/nuspec.xsd">
  <metadata minClientVersion="3.3.0">
    <id>Models</id>
    <version>1.0.0</version>
    <description>T4 Include file to generate a code.</description>
    <authors>Mark Shevchenko</authors>
  </metadata>

  <files>
    <file src="Models.ttinclude" target="content/Models.ttinclude" />
  </files>
</package>
```

Обязательными реквизитами пакета являются `id`, `version`, `description` и `authors`.

Запустим утилиту сборки пакета:

```
nuget pack Models.spec
```

Утилита создаст пакет с именем **Models.1.0.0.nupkg**. Пакет NuGet это обычный zip-архив, поэтому мы можем переименовать его в **Models.1.0.0.zip** и исследовать.
В корне архива мы обнаружим спецификацию **Models.spec** и папку **content**, где лежит **Models.ttinclude**.

```
├─ Models.spec
└─ content
   └─ Models.ttinclude
```

Откуда появилась папка **content**? Ответ мы найдём в разделе `files` спецификации **Models.spec**:

```
    <file src="Models.ttinclude" target="content/Models.ttinclude" />
```

Утилита **nuget.exe**, встретив элемент `file` копирует файл из атрибута `src` в папку из атрибута `target`.

Создадим пустой проект .NET Framework (не .NET Core и не .NET Standard) и установим пакет.

> Удобно добавить папку, где лежит **Models.1.0.0.nugpk** в список *Available package sources*. В Visual Studio выберите *Tools*&nbsp;&rarr;*NuGet Package Manager*&nbsp;&rarr;
> *Package Manager Settings*&nbsp;&rarr;*Package sources*. После добавления папке запустите *Package Manager*, правой клавишей мыши щёлкнув на проекте .NET Framework
> и выбрав *Manage NuGet Packages*. Справа вверху выберите *package source*, где находится пакет **Models.1.0.0.nupkg**, и установите.

После установки **Models.ttinclude** будет скопирован в корень проекта. Это именно то, что нам нужно.

## Шаг III: проекты .NET Core и .NET Standard

Веселиться, конечно, рано. Если мы установим пакет в проект .NET Core или .NET Standard, файла **Models.ttinclude** мы не увидим. Не увидим потому,
что в 4-й версии NuGet появился
[новый способ поставки файлов](https://docs.microsoft.com/ru-ru/nuget/reference/nuspec#using-the-contentfiles-element-for-content-files)&nbsp;&mdash;.
Теперь файл **Models.ttinclude** должен лежать не в папке **content**, а в папке **contentFiles/any/any**. Впрочем, в папке **content** его тоже надо оставить
для совместимости с проектами .NET Framework.

Дополним спецификацию пакета **Models.spec**:

```xml
<?xml version="1.0" encoding="utf-8"?>
<package xmlns="http://schemas.microsoft.com/packaging/2011/08/nuspec.xsd">
  <metadata minClientVersion="3.3.0">
    <id>Models</id>
    <version>1.0.0</version>
    <description>T4 Include file to generate a code.</description>
    <authors>Mark Shevchenko</authors>
    <contentFiles>
      <files include="**/Models.ttinclude" buildAction="None" />
    </contentFiles>
  </metadata>

  <files>
    <file src="Models.ttinclude" target="content/Models.ttinclude" />
    <file src="Models.ttinclude" target="contentFiles/any/any/Models.ttinclude" />
  </files>
</package>
```

Мы добавили элемент `contentFiles`, в котором описали действие, которое нужно выполнить с файлом **Models.ttinclude**
во вребя сборки. `None` означает, что ничего делать не нужно.

Имя файла указано в сокращённой форме **\*\*/Models.ttinclude**, полное имя&nbsp;&mdash; **contentFiles/any/any/Models.ttinclude**.
Инструкция `contentFiles` не копирует файлы: как и раньше, мы помещаем **Models.ttinclude** в **contentFiles/any/any** с помощью
элемента `file`:

```
    <file src="Models.ttinclude" target="contentFiles/any/any/Models.ttinclude" />
```

Осталось разобраться с тем, что означают папки **any/any**. NuGet позволяет публиковать разные файлы в проектах с разными языками и разными платформами.
В папку **cs/net45** мы поместим файлы проектов на C# для платформы .NET Framework 4.5, а в папку **vb/netstandard1.6**&nbsp;&mdash; файлы проектов на VisualBASIC
для платформы .NET Standard 1.6. Содержимое **any/any** будет скопировано в проекты на любом языке и для любой платформы.

> NuGet поддерживает типы проектов **cs**, **vb** и **fs**. Поддерживаемых целевых платформ [гораздо больше](https://docs.microsoft.com/ru-ru/nuget/reference/target-frameworks).

После сборки мы увидим в пакете такие файлы:

```
├─ Models.spec
├─ content
│  └─ Models.ttinclude
└─ contentFiles
   └─ any
      └─ any
         └─ Models.ttinclude
```

При установке пакета в проект .NET Framework NuGet, как и раньше, копирует файл **Models.ttinclude**. После установки пакета в проекты .NET Core и .NET Standard,
мы увидим файл в корне проекта, но если мы заглянем на диск, то файла там не обнаружим.

Файл находится в локальном кэше пакетов (**%USERPROFILE%\.nuget\packages\models\1.0.0\contentFiles\any\any**) и из проекта на него стоит ссылка.
Предполагается, что файлы из папки **contentFiles** нельзя изменять, поэтому один и тот же файл можно включать в разные проекты. Однако, у нас возникает проблема: директива `@include` не видит этого файла в папке проекта и не может его включить.

## Шаг IV: путь к включаемому файлу в T4

К нашему счастью, шаблонизатор T4 может быть интегрирован с Visual Studio и MSBuild. Интеграция заключается в том, что мы можем &laquo;передать&raquo; шаблонизатору свойства
проекта как параметры.

Добавим в файл проекта свойство `$(ModelsIncludeFolder)`:

```xml
<PropertyGroup>
  <ModelsIncludeFolder>$(%USERPROFILE)\.nuget\packages\models\1.0.0\contentFiles\any\any</ModelsIncludeFolder>
</PropertyGroup>
```

&laquo;Передадим&raquo; его в T4:

```xml
<ItemGroup>
  <T4ParameterValues Include="ModelsIncludeFolder">
    <Value>$(ModelsIncludeFolder)</Value>
  </T4ParameterValues>
</ItemGroup>
```

Теперь свойство `$(ModelsIncludeFolder)` можно использовать в шаблоне, в частности, в директиве `@include`:
```
<#@ include file="$(ModelsIncludeFolder)\Models.ttinclude" #>
```

Если мы перенесём этот код в проект .NET Framework, куда **Models.ttinclude** просто копируется, он перестанет работать. Чтобы сохранить совместимость
в проектах разного вида, сделаем `$(ModelsIncludeFolder)` равным `$(MSBuildProjectDirectory)`, то есть корню проекта.

```xml
<PropertyGroup>
  <ModelsIncludeFolder>$(MSBuildProjectDirectory)</ModelsIncludeFolder>
</PropertyGroup>
```

Осталось разобраться, как добавить в файл проекта свойство при установке пакета. Это несложно. В состав пакета могут входить файлы с расширениями **.props** и
**.targets**. NuGet проверяет целевую платформу проекта, и ищет подходящий файл в папке **build**, скажем, для проекта .NET Standard поиск происходит
в папке **build/netstandard**, а для .NET Framework&nbsp;&mdash; в папке **build/net**.

Если файлы найдены, NuGet [импортирует](https://docs.microsoft.com/ru-ru/visualstudio/msbuild/import-element-msbuild) **.props** в начало файла проекта,
а **.target**&nbsp;&mdash; в конец. В проектах .NET Core и .NET Standard импорт осуществляется чуть сложнее&nbsp;&mdash; через файл **project.assets.json**, но 
в конечном счёте происходит то же самое.

Создадим два файла **.props** и один файл **.targets** (он идентичен для всех типов проектов).

**Models.netstandard.props**
```xml
<?xml version="1.0"?>
<Project>
  <PropertyGroup>
    <ModelsIncludeFolder>$(NuGetPackageRoot)models\1.0.0\contentFiles\any\any</ModelsIncludeFolder>
  </PropertyGroup>
</Project>
```

**Models.net.props**
```xml
<?xml version="1.0"?>
<Project>
  <PropertyGroup>
    <ModelsIncludeFolder>$(MSBuildProjectDirectory)</ModelsIncludeFolder>
  </PropertyGroup>
</Project>
```

**Models.targets**
```xml
<?xml version="1.0"?>
<Project>
  <ItemGroup>
    <T4ParameterValues Include="ModelsIncludeFolder">
      <Value>$(ModelsIncludeFolder)</Value>
    </T4ParameterValues>
  </ItemGroup>
</Project>
```

Добавим в раздел `files` **Models.spec** ещё четыре строки:

```xml
  <files>
    <file src="Models.ttinclude" target="content/Models.ttinclude" />
    <file src="Models.ttinclude" target="contentFiles/any/any/Models.ttinclude" />

    <file src="Models.net.props" target="build/net/Models.props" />
    <file src="Models.targets" target="build/net/Models.targets" />
    <file src="Models.netstandard.props" target="build/netstandard/Models.props" />
    <file src="Models.targets" target="build/netstandard/Models.targets" />
  </files>
```

Структура пакета:

```
├─ Models.spec
├─ content
│  └─ Models.ttinclude
├─ contentFiles
│  └─ any
│     └─ any
│        └─ Models.ttinclude
└─ build
   ├─ net
   │  ├─ Models.props
   │  └─ Models.targets
   └─ netstandard
      ├─ Models.props
      └─ Models.targets
```

Важно разместить файлы платформы `net` перед файлами платформы `netstandard` потому что NuGet использует первые подходящие файлы,
а последние версии .NET Framework совместимы с .NET Standard.

## Заключение

Теперь наш пакет может быть установлен как в проекты .NET Core/Standard, так и в проекты .NET Framework. В первом случае в проект добавляется
ссылка на файл в кэше пакетов, а во втором&nbsp;&mdash; копия файла из пакета.

В обоих случаях мы используем путь `"$(ModelsIncludeFolder)\Models.ttinclude"` в директиве `@include`.