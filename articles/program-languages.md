Языки программирования через 10 лет
В предсказатели я не гожусь. Занятие это требует большой самоуверенности, которая с возрастом обычно компенсируется жизненным опытом. Но поскольку процесс компенсации подробно в литературе не описан, я никак не могу найти необходимый баланс. Самоуверенность требует поделиться сакральным знанием, а жизненный опыт подсказывает, что относиться к нему можно только с юмором. Поэтому предлагаю читателям считать статью не предсказанием, а поводом для раздумий.
В конце концов, можем мы потрепаться на общие темы?
Начну с ретроспективы. Историю языков программирования можно разложить в простую схему, которая, как и все простые схемы, ошибочна. Например, я могу сказать, что первая веха в становлении программирования — это период с 45-го по 55-й год. Удобно, что числа почти круглые, неудобно, что неверные. Железки-то первые появились чуть раньше, и писать программы в промышленных масштабах начали не позднее 43-го года. Средством общения с компьютером были машинные коды и язык ассемблера. Период закончился с появлением в 54-м году первого высокоуровневого языка программирования Фортран.
Согласитесь, «веха 43-54» выглядит совершенно не кругло. Впрочем, и вехой то её назвать непросто — на языке ассемблера массово писали ещё в середине 80-х, по крайней мере, на персональных машинах. Но в 40-е годы ничего другого просто не было.
Машинные коды — это чистый компьютерный язык. Поскольку архитектура компьютеров была основана на модели Тьюринга, первые программы были императивными, то есть содержали последовательность приказов. Точно таким же императивным языком стал и Фортран.
Его основное преимущество замечательно раскрывается в названии — Formula Translator. Фортран научился делать одну простую, но очень важную работу — переводить операторы вида SQRT(X + Y * 38.7) в последовательность машинных команд. В остальном отличие от языка ассемблера было незначительным, даже условный оператор в его привычной форме if…then…else в Фортране отсутствовал. Вместо него программист ставил метки, управление на которые передавалось, если выражение оказывалось меньше, больше или равно нулю.
Впрочем, отмечу ещё два важных нововведения. Во-первых, это оператор цикла DO, который не имел аналога в языке ассемблера. Эта конструкция «собиралась» из IF и GOTO, то есть, по сути, являлась синтаксическим сахаром. Интересно, что почти через 15 лет она стала одним из столпов структурного программирования.
Во-вторых, это стандартизация вызова процедур. Программируя на машинном языке, мы можем вызывать подпрограммы, самостоятельно организуя отправку параметров и возврат значений через регистры, стек, кучу и даже глобальную память. Даже в пределах одной программы допустимо произвольным образом смешивать разные способы вызова. Однако Фортран положил этому конец, что позволило стыковать подпрограммы, написанные на разных языках, и привело к появлению модульного программирования.
Следующие 15 лет (ориентировочно 55-70гг.) индустрия спокойно развивалась, накапливая математические библиотеки.
Конец эпохи Фортрана принято связывать со знаменитой статьёй Дейкстры «Оператор GOTO — объявить вредным», которая вышла в 1968г. В данном случае слова «конец эпохи» следует воспринимать условно, поскольку в математических программах Фортран активно используется до сих пор.
Что же случилось? Ровным счётом ничего, если не считать большого количества ошибок. Интересно, что развитие языков программирования можно привязать к самым распространённым ляпам каждой эпохи. При программировании на Фортране бичом программистов стал так называемый спагетти-код, в котором очень сложно отследить порядок выполнения, поскольку управление постоянно передаётся то вверх, то вниз.
Дейкстра предложил несколько принципов, которые позволили читать подпрограмму сверху вниз. Собственно, он доказал, что любой спагетти-код можно преобразовать в последовательность одиночных операторов, циклов и ветвлений. Характерно, что структурное программирование поддерживал уже Алгол-60, однако, массовую популярность методология получила только в 70-е годы.
Помимо структуры, в языки программирования стала проникать концепция объявлений, которая позволила исключить большой класс ошибок-опечаток. Обычно объявления переменных связывают (или путают) со статической типизацией, однако, например, в языке Перл есть режим strict vars, при котором каждая переменная должна быть объявлена, а вот значение (и тип) ей можно назначить значительно позже.
Структурное программирование довольно долго оставалось главной парадигмой индустрии — практически 20 лет (70-90гг.), и это не смотря на то, первым объектно-ориентированным языком принято считать Симулу, созданную в 1967г.
Как ни странно, такое продолжительный застой связан в первую очередь с прогрессом в области железа. Удивлены?
Рубеж 70-80 годов оказался роковым для программистов. Компьютеры дешевели, росли объёмы оперативной памяти и быстродействие. В этих условиях активно развивались «ресурсоёмкие» языки — Смолток, различные варианты LISP и ML. Однако появление персоналок вернуло нас на 10 лет назад, в ситуацию, где битва шла за каждый килобайт.
Смолток для первых Atari, Apple и IBM PC оказался слишком требовательным.
Впрочем, история шла своим чередом. В 1983г. молодой (тогда ещё) программист Бьярн Страустрап, размышляя об эффективной реализации полиморфизма, придумал простой и элегантный способ переопределения методов через таблицу виртуальных функций. Способ оказался настолько хорош, что используется сейчас не только в Си++, но и в подавляющем большинстве современных объектно-ориентированных языков. Приблизительно в начале 90-х годов наступила эпоха объектно-ориентированного программирования. Что же в нём хорошего? Объектная парадигма упрощает решение двух важных задач, возникающих в индустрии. Одна из них касается повторного использования кода, а вторая — совместной разработки программ. Решения, конечно, предлагались и раньше (процедурное и модульное программирование), но они переставали работать на сложных проектах.
Наверное, настало время отметить, что каждая новая парадигма не отменяла предыдущую, а, скорее, развивала. Структурный Паскаль, оставался таким же императивным языком, как и Фортран, а объектно-ориентированная Java — такой же структурной, как и Модула-2.
Каждый «переход» делал код менее эффективным, но более удобным для написания и сопровождения. Потерю производительности нивелировала возрастающая мощность компьютеров.
В 1995-м году появился новый язык программирования — Java, призванный решить основные проблемы Си++, накопившиеся к тому времени. С моей точки зрения, самыми важными нововведениями стали виртуальная машина и сборщик мусора, и чуть ниже я расскажу, почему. Как всегда, основной претензией к первым версиям Java стала низкая производительность (по сравнению с Си++). Впрочем, уже тогда было понятно, что существует большой класс задач, для которых этой производительности хватает. Рост мощностей компьютеров и планомерная работа авторов языка над виртуальной машиной и сборщиком мусора привели к ожидаемому результату — ныне Java фактически вытеснила Си++ из прикладного программирования.
Период с 2000г., когда Java получила повсеместное признание и по наши дни, можно считать новой эпохой, эпохой высокоуровневого объектного программирования. Как обычно, круглая дата является приблизительной, поскольку не стоит относиться к ней с абсолютной серьёзностью. Точно также не стоит серьёзно воспринимать пафосную фразу о «высокоуровневом объектном программировании» — она, скорее, свидетельствует о моём неумении подобрать более человечное название.
Язык Си++ оказался очень сложным из-за того, что решал одновременно множество задач (совместимость с Си, высокая эффективность, поддержка обобщённого и объектного программирования). Разработчики Java, отринув наследие 70-х, сумели создать доступный Си++, между простой и эффективностью выбирая простоту.
И проложили дорогу функциональным языкам.

