---
title: Фильтрация треков GPS на F#, Часть III
id: fsharp-gps-tracks-filtration-2
excerpt: Фрагменты лекции, прочитанной в Московском клубе программистов 21 февраля 2019 года.
mathjax: true
---

## Фильтр Калмана

Мы добрались до самого интересного&nbsp;&mdash; сглаживания треков. Программа, которую мы напишем, будет короткой и простой, но за этой простотой скрывается нетривиальная математика.

Попробуем разобраться.

### Модель

В чём задача сглаживания? На автомобиле установлен датчик GPS, который определяет его координаты каждые несколько секунд. Показания датчика не очень точные, поэтому трек получается неровным.

Чтобы его *выровнять*, нам нужно что-то, что позволит исправлять ошибки датчика. В методе Калмана это *что-то*&nbsp;&mdash; математическая модель.

Рассмотрим утрированно простой вариант движения автомобиля&nbsp;&mdash; представим, что он передвигается в одномерном пространстве.

![Модель движения автомобиля](/img/kalman-1.png){: .picture}

Автомобиль едет по прямой дороге. Время от времени мы определяем его положение и скорость. На шаге $i$ координата автомобиля равна $x_i$, а скорость равна $u_i$. На шаге $i + 1$, через время $\Delta t$, новая координата будет равна $x_{i+1}$.

$$
x_{i+1} = x_i + u_i \Delta t
$$

Это и есть модель движения автомобиля. Мы видим, что она простая, и не учитывает, например, *ускорения*, поэтому её предсказания будут обладать *погрешностью*.

Математически идею идею погрешности можно выразить, добавив в равенство случайную величину. Обозначим её греческой буквой *кси*, $\xi$.

$$
x_{i+1} = x_i + u_i \Delta t + \xi_i
$$

Индекс $i$ у $\xi$ показывает, что пограшеность в каждой точке разная. Действительно ли она случайна? Мы не знаем. Наверное можно было бы сделать модель сложнее, и вычислять погрешность с большей точностью, но у нас нет задачи строить сложные модели.

На практике не важно, действительно ли погрешность случайна или она только *похожа* на случайную&nbsp;&mdash; мы в любом случае можем применить к ней математический аппарат.

### Вспоминаем теорию вероятностей

Поскольку погрешность это *непрерывная случайная величина*, при каждом измерении мы будем получать новое значение, которое невозможно предсказать заранее. Проведя множество измерений, мы сможем утверждать о случайной величине кое-что определённое.

![Случайная величина](/img/kalman-2.png){: .picture}

Первое что характеризует случайную величину, это &laquo;центр&raquo; вокруг которого концентруются значения. Он называется *математическим ожиданием* и обозначается буквой $E$ от *expectation*&nbsp;&dash; *ожидание*. Математическое ожидание вычисляется как среднее арифметическое всех имеющихся значений.

$$
E \xi = \frac{\xi_1 + \xi_2 + ... + \xi n}{n}
$$

На приведённом рисунке среднее случайной величины равно 2. Кроме среднего, мы можем рассчитать *меру разброса*.

Ещё раз посмотрим на график. Мы видим, что разброс достигает единицы, но это максимальное значение.


Прежде, чем двигаться дальше, давайте вспомним основные положения теории вероятностей.

Здесь $x^r_i$ это *реальная* координата (верхний индекс *r* от слова *real*), а $x^a_i$&nbsp;&mdash; *приближение* (*a* от слова *approximation*). Греческой буквой *кси* ($\xi$) мы обозначили *погрешность*.

Чему равна погрешность? Мы не знаем. Возможно, её можно вычислить, используя более точную модель и рассчитав разницу. Но мы упростим себе рассуждения, предположив, что погрешность&nbsp;&mdash; это случайная величина.

Погрешностью обладает не только модель, но и датчик GPS:

$$
x^s_i = x^r_i + \eta_i
$$

$x^s_i$ это координата, полученная с датчика, который по английски называется *sensor*. Чтобы не путать разные погрешности, погрешность датчика мы обозначим греческой буквой *эта* ($\eta$).

У нас две греческие буквы, и три верхних индекса *r*, *a* и *s*&nbsp;&mdash; пока ничего страшного.



Итак, в точке $i$ датчик вовзращает нам координату $x^s_i$ и скорость $u^s_i$. Мы хотим скорректировать координату, чтобы сделать трек более гладким.

В результате применения фильтра мы получим достаточно хорошее *приближение* координаты $x$ к идеалу. Мы будем помечать скорректированную координату буквой *a* от слова *approximation* (*приближение*).

Через время $\Delta t$ на шаге $i + 1$ мы получаем координату от датчика $x^s_{i+1}$ и попробуем вычислить следующее приближение $x^a_{i+1}$.

Что для этого нужно? Вы не поверите, но это ещё одна координата, на этот раз реальная координата автомобиля, которую мы обозначим $x^r_{i+1}$. Буква $r$ первая в слове *real* (*реальная*).

На самом деле мы не знаем реальной координаты, но она позволяет выразить приближение через показания сенсора.


$$
x^r_{i+1} = x^r_i + u^s_i \Delta t
$$

Эта модель движения работает с погрешностью, поскольку не учитывает ускорения, ускорения ускорения, поворотов и других факторов. Вместо усложения и уточнения модели мы явно обозначим разницу греческой буквой *кси*, как часто обозначают случайные величины. Конечно, погрешность не является случайной величиной, но мы можем считать её таковой. Так иногда делают в физике, чтобы упростить расчёты. Запишем формулу определения следующей координаты с учётом погрешности:

$$
x^r_{i+1} = x^r_i + u^s_i \Delta t + \xi_i
$$

Индекс $i$ у буквы $\xi$ означает, что погрешности в каждой точке измерения будут разными.

Если мы измеряем расстояние в метрах, то значение погрешности также будет в метрах, например, +0,5 метра или -0,3 метра. У нас много значений погрешности, поэтому мы можем посчитать *среднее*&nbsp;&mdash; $E \xi$. $E$ это сокращение от *expectation*, то есть *ожидание*. *Математическое ожидание*&nbsp;&mdash; другое название для среднего.


> Если у нас хорошая модель, математическое ожидание погрешности будет равным нулю: все положительные ошибки нивелируются отрицательными. В дальнейшем мы предполагаем, что речь идёт о хорошей модели и $E \xi = 0$.

Кроме ожидания случайная величина характеризиуется разбросом, то есть тем, насколько далеко она находится от среднего значения. Традиционно мерой разброса является *дисперсия*, которая обозначается маленькой буквой *сигма*:

$$
\sigma \xi^2 = E(\xi - E \xi)^2
$$

$\sigma \xi$&nbsp;&mdash; *среднеквадратичное отклонение*, *стандартное отклонение* или *стандартный разброс*. Вычисляется, как квадратный корень из дисперсии.

Подключим к нашей машине GPS-трекер, который будет возвращать её координату. Поскольку сенсор работает с погрешностью, координата сенсора будет отличаться от реальной координаты на случайную величину, которую мы обозначим греческой буквой *эта*.

$$
x^s_{i + 1} = x^r_{i + 1} + \eta_{i + 1}
$$

Здесь $x^r_{i + 1}$&nbsp;&mdash; истинное значение координаты, а $\eta_{i + 1}$&nbsp;&mdash; случайная погрешность сенсора.

> Как и в случае с моделью, мы предполагаем, что математическое ожидание погрешности сенсора равно 0: $E \eta = 0$.

### Постановка задачи

Предположим, мы находимся где-то в середине пути, в точке $i$. Предположим, мы вычислили координату $x$ в $i$-той точке, $x^a_i$. Буква *a* означает *approximation*, то есть *приближение*.

Сенсор возвращает нам текущую координату $x^s_i$ и скорость $u^s_i$.

Через время $\Delta t$ мы получаем с сенсора координату $x^s_{i+1}$.

Опираясь на модель, мы можем предсказать следующую координату: $x^a_i + u^s_i \Delta t$.

Предполагается, что следующая координата, которую мы вычислим, находится где-то между предсказанной и полученной с сенсора. Задача нахождения значения функции внутри интервала назыается *интерполяцией*. Простейшая интерполяция&nbsp;&mdash; *линейная*.

$$
x^a_{i+1} = K x^s_{i+1} + (1 - K)(x^a_i + u^s_i \Delta t)
$$

Здесь $K$&nbsp;&mdash; это коэффициент Калмана, который показывает, какой *вес* имеют показания сенсора. Если вес сенсора равен 30%, то вес модели 70%. Значение коэффициента находится в интервале от 0 до 1 включительно.

*Ошибкой предсказания* назовём разницу между $x^r_{i+1}$ и $x^a_{i+1}$:

$$
e_{i+1} = x^r_{i+1} - x^a_{i+1}
$$

Наша задача&nbsp;&mdash; минимизировать ошибку. Если взглянуть на формулу вычисления $x^a_{i+1}$, мы видим, что, изменяя $K$, можем изменить результат, следовательно нам на каждом шаге надо пересчитывать $K$, чтобы минимизировать ошибку.

Мы будем минимизировать квадрат ошибки, то есть $E e^2_{i+1}$.

