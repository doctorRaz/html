---
title: Фильтрация треков GPS на F#, Часть III
id: fsharp-gps-tracks-filtration-2
excerpt: Фрагменты лекции, прочитанной в Московском клубе программистов 21 февраля 2019 года.
mathjax: true
---

## Фильтр Калмана

Рассмотрим задачу движения автомобиля в одномерном пространстве.

Нам известна координата автомобиля в текущий момент времени, обозначим её $x^r_i$. Буква $r$ означает, что мы берём реальную (real) координату. Сенсор возвращает скорость автомобиля в точке $x^r_i$, обозначим её $u^s_i$. Буква $s$ означает, что скорость получена с сенсора. Через некоторое время, традиционно обозначаемое $\Delta t$ (дельта тэ), автомобиль попадёт в точку $x^r_{i+1}$:

$$
x^r_{i+1} = x^r_i + u^s_i \Delta t
$$

Эта модель движения работает с погрешностью, поскольку не учитывает ускорения, ускорения ускорения, поворотов и других факторов. Вместо усложения и уточнения модели мы явно обозначим разницу греческой буквой *кси*, как часто обозначают случайные величины. Конечно, погрешность не является случайной величиной, но мы можем считать её таковой. Так иногда делают в физике, чтобы упростить расчёты. Запишем формулу определения следующей координаты с учётом погрешности:

$$
x^r_{i+1} = x^r_i + u^s_i \Delta t + \xi_i
$$

Индекс $i$ у буквы $\xi$ означает, что погрешности в каждой точке измерения будут разными.

Если мы измеряем расстояние в метрах, то значение погрешности также будет в метрах, например, +0,5 метра или -0,3 метра. У нас много значений погрешности, поэтому мы можем посчитать *среднее*&nbsp;&mdash; $E \xi$. $E$ это сокращение от *expectation*, то есть *ожидание*. *Математическое ожидание*&nbsp;&mdash; другое название для среднего.

$$
E \xi = \frac{\xi_1 + \xi_2 + ... + \xi n}{n}
$$

> Если у нас хорошая модель, математическое ожидание погрешности будет равным нулю: все положительные ошибки нивелируются отрицательными. В дальнейшем мы предполагаем, что речь идёт о хорошей модели и $E \xi = 0$.

Кроме ожидания случайная величина характеризиуется разбросом, то есть тем, насколько далеко она находится от среднего значения. Традиционно мерой разброса является *дисперсия*, которая обозначается маленькой буквой *сигма*:

$$
\sigma \xi^2 = E(\xi - E \xi)^2
$$

$\sigma \ksi$&nbsp;&mdash; *среднеквадратичное отклонение*, *стандартное отклонение* или *стандартный разброс*. Вычисляется, как квадратный корень из дисперсии.

Подключим к нашей машине GPS-трекер, который будет возвращать её координату. Поскольку сенсор работает с погрешностью, координата сенсора будет отличаться от реальной координаты на случайную величину, которую мы обозначим греческой буквой *эта*.

$$
x^s_{i + 1} = x^r_{i + 1} + \eta_{i + 1}
$$

Здесь $x^r_{i + 1}$&nbsp;&mdash; истинное значение координаты, а $\eta_{i + 1}$&nbsp;&mdash; случайная погрешность сенсора.

> Как и в случае с моделью, мы предполагаем, что математическое ожидание погрешности сенсора равно 0: $E \eta = 0$.

### Постановка задачи

Предположим, мы находимся где-то в середине пути, в точке $i$. Предположим, мы вычислили координату $x$ в $i$-той точке, $x^a_i$. Буква *a* означает *approximation*, то есть *приближение*.

Сенсор возвращает нам текущую координату $x^s_i$ и сокрость $u^s_i$.

Через время $\Delta t$ мы получаем с сенсора координату $x^s_{i+1}$.

Опираясь на модель, мы можем предсказать следующую координату: $x^a_i + u^s_i \Delta t$.

Предполагается, что следующая координата, которую мы вычислим, находится где-то между предсказанной и полученной с сенсора. Задача нахождения значения функции внутри интервала назыается *интерполяцией*. Простейшая интерполяция&nbsp;&mdash; *линейная*.

$$
x^a_{i+1} = K x^s_{i+1} + (1 - K)(x^a_i + u^s_i \Delta t)
$$

Здесь $K$&nbsp;&mdash; это коэффициент Калмана, который показывает, какой *вес* имеют показания сенсора. Если вес сенсора равен 30%, то вес модели 70%. Значение коэффициента находится в интервале от 0 до 1 включительно.

*Ошибкой предсказания* назовём разницу между $x^r_{i+1}$ и $x^a_{i+1}$:

$$
e_{i+1} = x^r_{i+1} - x^a_{i+1}
$$

Наша задача&nbsp;&mdash; минимизировать ошибку. Если взглянуть на формулу вычисления $x^a_{i+1}$, мы видим, что для минимизации ошибки мы можем управлять значением коэффициента $K$.

Мы будем минимизировать квадрат ошибки, то есть $E e^2_{i+1}$.

