---
title: Фильтрация треков GPS на F#, Часть III
id: fsharp-gps-tracks-filtration-2
excerpt: Фрагменты лекции, прочитанной в Московском клубе программистов 21 февраля 2019 года.
mathjax: true
---

## Фильтр Калмана

Рассмотрим задачу движения автомобиля в одномерном пространстве.

Нам известна координата автомобиля в текущий момент времени, обозначим её $x^r_i$. Буква $r$ означает, что мы берём реальную (real) координату. Сенсор возвращает скорость автомобиля в точке $x^r_i$, обозначим её $u^s_i$. Буква $s$ означает, что скорость получена с сенсора. Через некоторое время, традиционно обозначаемое $\Delta t$ (дельта тэ), автомобиль попадёт в точку $x^r_{i+1}$:

$$
x^r_{i+1} = x^r_i + u^s_i \Delta t
$$

Эта модель движения работает с погрешностью, поскольку не учитывает ускорения, ускорения ускорения, поворотов и других факторов. Вместо усложения и уточнения модели мы явно обозначим разницу греческой буквой *кси*, как часто обозначают случайные величины. Конечно, погрешность не является случайной величиной, но мы можем считать её таковой. Так иногда делают в физике, чтобы упростить расчёты. Запишем формулу определения следующей координаты с учётом погрешности:

$$
x^r_{i+1} = x^r_i + u^s_i \Delta t + \ksi_i
$$

Индекс $i$ у буквы $\ksi$ означает, что погрешности в каждой точке измерения будут разными.

Если мы измеряем расстояние в метрах, то значение погрешности также будет в метрах, например, +0,5 метра или -0,3 метра. У нас много значений погрешности, поэтому мы можем посчитать *среднее*&nbsp;&mdash; $E \ksi$. $E$ это сокращение от *expectation*, то есть *ожидание*. *Математическое ожидание*&nbsp;&mdash; другое название для среднего.

$$
E \ksi = \frac{\ksi_1 + \ksi_2 + ... + \ksi n}{n}
$$

> Если у нас хорошая модель, математическое ожидание погрешности будет равным нулю: все положительные ошибки нивелируются отрицательными. В дальнейшем мы предполагаем, что речь идёт о хорошей модели и $E \ksi = 0$.

Кроме ожидания случайная величина характеризиуется разбросом, то есть тем, насколько далеко она находится от среднего значения. Традиционно мерой разброса является *дисперсия*, которая обозначается маленькой буквой *сигма*:

*σ<sub>ξ</sub>*² = *E*(*ξ* - *Eξ*)²

*σ<sub>ξ</sub>*&nbsp;&mdash; *среднеквадратичное отклонение*, *стандартное отклонение* или *стандартный разброс*. Вычисляется, как квадратный корень из дисперсии.

Подключим к нашей машине GPS-трекер, который будет возвращать её координату. Поскольку сенсор работает с погрешностью, координата сенсора будет отличаться от реальной координаты на случайную величину, которую мы обозначим греческой буквой *эта*.

*xˢᵢ₊₁* = *xʳᵢ₊₁* + *ηᵢ₊₁*

Здесь *xʳᵢ₊₁*&nbsp;&mdash; истинное значение координаты, а *ηᵢ₊₁*&nbsp;&mdash; случайная погрешность сенсора.

> Как и в случае с моделью, мы предполагаем, что математическое ожидание погрешности сенсора равно 0: *Eη* = 0.

### Постановка задачи

Предположим, мы находимся где-то в середине пути, в точке *i*. Предположим, мы вычислили координату *x* в *i*-той точке, *xᵃᵢ*.
Буква *a* означает *approximation*, то есть *приближение*.

Сенсор возвращает нам текущую координату *xˢᵢ* и сокрость *uˢᵢ*.

Через время Δt мы получаем с сенсора координату *xˢᵢ₊₁*.

Опираясь на модель, мы можем предсказать следующую координату: *xᵃᵢ + *uˢᵢ* × *Δt*.

Предполагается, что следующая координата, которую мы вычислим, находится где-то между предсказанной и полученной с сенсора. Задача нахождения значения функции внутри интервала назыается *интерполяцией*. Простейшая интерполяция&nbsp;&mdash; *линейная*.

*xᵃᵢ₊₁* = *K* × *xˢᵢ₊₁* + (1 - *K*) × (*xᵃᵢ + *uˢᵢ* × *Δt*)

Здесь *K*&nbsp;&mdash; это коэффициент Калмана, который показывает, какой *вес* имеют показания сенсора. Если вес сенсора равен 30%, то вес модели 70%. Значение коэффициента находится в интервале от 0 до 1 включительно.

*Ошибкой предсказания* назовём разницу между *xʳᵢ₊₁* и *xᵃᵢ₊₁*:

*eᵢ₊₁* + *xʳᵢ₊₁* - *xᵃᵢ₊₁*

Наша задача&nbsp;&mdash; минимизировать ошибку. Если взглянуть на формулу вычисления *xᵃᵢ₊₁*, мы видим, что для минимизации ошибки мы можем управлять значением коэффициента *K*.

Мы будем минимизировать дисперсию ошибки то есть *E*(*e*<sup>2</sup><sub>i + 1</sub>)

