---
title: Фильтрация треков GPS на F#, Часть I
id: fsharp-gps-tracks-filtration-1
excerpt: Фрагменты лекции, прочитанной в Московском клубе программистов 21 февраля 2019 года.
---

## Проблематика

На рисунке показан типичный *трек*, полученный с *датчика* (*сенсора*) GPS на мобильном телефоне во время движения.

![Фильрация треков GPS](/img/gps-track-filtering-1.png){: .picture}

Чёрным цветом нарисован реальный путь автомобиля или человека, а синим&nbsp;&mdash; координаты, полученные с датчика. Как видим, пути существенно различаются. Если вы хотите вычислить скорость и пройденное расстояние, точность ваших вычислений окажется невысокой.

Мы поговорим о методах, которые помогут превратить синюю линию в красную. Красная линия&nbsp;&mdash; это *приближение*, вычисленное на основании реальных синих точек.

## Данные GPS

Мобильные телефоны оснащены *датчиками* (*сенсорами*), которые позволяют определять положение, ориентацию и ускорение устройства. Нам для наших целей понадобятся:

1. *Широта* и *долгота* (*latitude* и *longitude*)&nbsp;&mdash; координаты устройства. Измеряются в градусах.
1. *Скорость* (*speed*). Измеряется в метрах в секунду.
1. *Направление* (*heading*)&nbsp;&mdash; направление движения *относительно севера*. Измеряется в градусах, положительное направление по часовой стрелке.
1. *Метка времени* (*timestamp*)&nbsp;&mdash; дата и время получения координаты.

Опишем *объект-значение* `SensorItem`, в котором будем хранить перечисленные параметры точки:

**Types.fs**
```ocaml
module Types

open System


type SensorItem(latitude: float, longitude: float, speed: float, heading: float, timestamp: DateTimeOffset) =
    member __.Latitude = latitude
    member __.Longitude = longitude
    member __.Timestamp = timestamp
    member __.Speed = speed
    member __.Heading = heading

    override __.GetHashCode() =
        hash (latitude, longitude, timestamp, speed, heading)

    override __.Equals(other) =
        match other with
        | :? SensorItem as x -> (latitude, longitude, timestamp, speed, heading) = (x.Latitude, x.Longitude, x.Timestamp, x.Speed, x.Heading)
        | _ -> false
```

Для типов проекта создадим модуль **Types.fs**. Строка `module Types` позволит в дальнейшем использовать объявленные типы в других модулях. F# не требует, чтобы имя файла и имя модуля совпадали, но мы будем придерживаться этого соглашения.

Строка `open System` позволяет обращаться к типам, описанным в пространстве имён `System`. Она нужна, поскольку мы используем `DateTimeOffset`, для которого в F# нет «родного» названия, такого как `float`. Кстати, из-за совместимости с OCaml, в F# `float` означает тип, который в C# называется `double`.

Мы описали класс `SensorItem` с пятью свойствами, значения которых инициализируются в конструкторе и больше никогда не меняются. Слово *item* можно перевести на русский язык по разному, в нашей программе под *sensor item* мы понимаем *показание датчика*.

Поскольку состояние объекта не может быть изменено, он соответствует паттерну *объект-значение*, который описан в книге Мартина Фаулера *Архитектура копроративных программных приложений* (стр. 500) и в книге Эрика Эванса *Предметно-ориентированное проектирование* (стр. 101).

Объекты-значения неизменны или, как говорят функциональщики, *иммутабельны*.

Я переопределил методы `GetHashCode` и `Equals`, поскольку мне нужен `Equals` для тестирования: `Assert.Equal` вызывает его при сравнении последовательностей. Давайте вкратце их обсудим, потому что они могут вызывать вопросы.

В действительности нам нужен только метод `Equals`, но, если вы сталкивались с .NET, то знаете, что его переопределение без `GetHashCode` приводит к предупреждению. Реализация `GetHashCode` максимально проста, мы создаём *кортеж* из наших переменных, записав их в скобках, и просим F# вычислить его хэш, вызвав функцию [`hash`](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/operators.hash%5B%27t%5D-function-%5Bfsharp%5D).

Внутри метода `Equals` встречается конструкция `:? SensorItem as x`. Означает она буквально следующее: если параметр `other` имеет тип `SensorItem`, назовём его `x` и используем в правой части выражения после стрелки. `| _ -> false` означает, что во всех остальных случаях метод вернёт `false`, то есть переменные не будут считаться равными.

На языке C# тот же самый код будет выглядеть так:

```c#
namespace Types
{
    using System;

    public class SensorItem
    {
        public double Latitude { get; }

        public double Longitude { get; }

        public double Speed { get; }

        public double Heading { get; }

        public DateTimeOffset Timestamp { get; }

        public SensorItem(double latitude, double longitude, double Speed, double Heading, DateTimeOffset timestamp)
        {
            Latitude = latitude;
            Longitude = longitude;
            Speed = speed;
            Heading = heading;
            Timestamp = timestamp;
        }

        public override int GetHashCode()
        {
            return (Latitude, Longitude, Speed, Heading, Timestamp).GetHashCode();
        }

        public override bool Equals(object other)
        {
            if (other is SensorItem otherItem)
            {
                return Latitude == otherItem.Latitude
                    && Longitude = otherItem.Longitude
                    && Speed = otherItem.Speed
                    && Heading = otherItem.Heading
                    && Timestamp = otherItem.Timestamp;
            }

            return false;
        }
    }
}
```

## Этапы обработки трека

Обработка трека состоит из трёх стадий: *стабилизации*, *сглаживания* и *прореживания*. В этой части статьи мы начнём разговор о стабилизации, и продолжим его во второй части.

Стабилизация позволяет избавиться от некорректных точек трека, либо за счёт фильтрации, либо за счёт небольшой модификации. Этот этап необходим, чтобы *сглаживание* и *прореживание* работали корректно.

К стабилизации относятся следующие методы обработки трека:

1. Удаление нулевых и отрицательных интервалов времени.
1. Устранение всплесков скорости.
1. Замена дрейфа нулевой скорости нулём.

### Удаление нулевых и отрицательных интервалов времени (Removing Data with Duplicate/Negative Time Records)

Для того, чтобы вычислить координаты, датчик GPS опирается на время, передаваемое со спутников. Мы не станем углубляться в теорию, просто отметим, что вместе с каждыми координатами мы получаем метку времени (timestamp).

Накладки всё-таки возможны, и старая координата устройства может появиться в треке позже новой. Иногда две соседние координаты имеют одну и ту же метку.

В первом случае интервал времени между соседними точками отрицателен, во втором&nbsp;&mdash; равен нулю. В обоих случаях нам надо удалить координаты с отрицательными или нулевыми интервалами.

Для начала напишем *заготовку* функции, которая будет отбрасывать показания с временной меткой из прошлого.

**Filters.fs**
```ocaml
module Filters

open System
open Types


/// <summary>
/// Removes points with zero or negative time spans.
/// </summary>
let removeZeroOrNegativeTimespans points =
    points
```

В нашей первой верии функция ничего не делает, просто возвращает тот же список, который получает в качестве параметра.

Я хочу написать *модульные тексты* для функции `removeZeroOrNegativeTimespans`. Visual Studio 2017 позволяет писать тесты для F# с помощью разных фреймворков. Я выбрал **XUnit**.

Для начала убедимся, что функция, получая пустой список, также возвращает пустой список.

**FilterTests.fs**
```ocaml
open System
open Xunit
open Types
open Filters


[<Fact>]
let ``removeZeroOrNegativeTimespans - with empty points - returns empty points`` () =
    let source = []

    let actual = removeZeroOrNegativeTimespans source

    Assert.Empty(actual)
```

Двойные *обратные апострофы*, то есть знаки \`\` позволяют использовать в названии функций произвольные символы, даже пробелы. Опираясь на рекомендацию Роя Оушерова (Искусство автономного тестирования, стр. 58&ndash;59) я назвал тестовый метод в соответствии с шаблоном *название метода*&nbsp;&mdash; *сценарий*&nbsp;&mdash; *ожидаемое поведение*. Название метода `removeZeroOrNegativeTimespans`, сценарий&nbsp;&mdash; with empty points, то есть &laquo;с пустыми списком точек&raquo;, а ожидаемое поведение&nbsp;&mdash; returns empty points, &laquo;возвращает пустой список точек&raquo;.

Атрибут `[<Fact>]` подсказывает фреймворку **XUnit**, что функция с именем `` `removeZeroOrNegativeTimespans - with empty points - returns empty list` `` должна быть вызвана при запуске тестов. *Утверждение* `Assert.Empty` позволяет проверить, что список, возвращённый функцией `removeZeroOrNegativeTimespans`, пуст.

Подобным образом напишем функцию, которая вернёт список из одного элемента, получив такой же список в параметре.

```ocaml
[<Fact>]
let ``removeZeroOrNegativeTimespans - with single point - returns single point`` () =
    let source = [SensorItem(0.0, 0.0, 0.0, 0.0, DateTimeOffset.Parse("2018-12-07T16:38:00+03:00"))]

    let actual = removeZeroOrNegativeTimespans source

    let expected = [SensorItem(0.0, 0.0, 0.0, 0.0, DateTimeOffset.Parse("2018-12-07T16:38:00+03:00"))]
    Assert.Equal<seq<SensorItem>>(expected, actual)
```

Утверждение `Assert.Equal<seq<SensorItem>>` позволяет сравнить две последовательности элементов. К последовательностям в F# относятся *перебираемые* объекты, то есть объекты тех классов, которые реализуют интерфейсы `IEnumerable` и `IEnumerable<T>`. Список F# также перебираемый объект.

Первые два теста должны запускаться без ошибок, не смотря на то, что код нашей функции ничего не делает. Теперь напишем тест, который &laquo;сломает&raquo; наивную реализацию. Передадим в качестве параметра список из трёх элементов, в котором дата и время второго элемента будут совпадать с датой и временем первого.

```ocaml
[<Fact>]
let ``removeZeroOrNegativeTimespans - with zero timespan - removes point`` () =
    let source = [SensorItem(0.0, 0.0, 0.0, 0.0, DateTimeOffset.Parse("2018-12-07T16:38:15+03:00"));
                  SensorItem(1.0, 1.0, 0.0, 0.0, DateTimeOffset.Parse("2018-12-07T16:38:15+03:00"));
                  SensorItem(2.0, 2.0, 0.0, 0.0, DateTimeOffset.Parse("2018-12-07T16:38:16+03:00"))]

    let actual = removeZeroOrNegativeTimespans source

    let expected = [SensorItem(0.0, 0.0, 0.0, 0.0, DateTimeOffset.Parse("2018-12-07T16:38:15+03:00"));
                    SensorItem(2.0, 2.0, 0.0, 0.0, DateTimeOffset.Parse("2018-12-07T16:38:16+03:00"))]
    Assert.Equal<seq<SensorItem>>(expected, actual)
```

Мы ожидаем, что функция `removeZeroOrNegativeTimespans` удалит из списка показание с нулевым интервалом, то есть вторую точку.

Этот тест у нас не пройдёт. Самое время написать корректную реализацию фильтра.

```ocaml
let removeZeroOrNegativeTimespans points =
    match points with
    | [] -> []
    | [p] -> [p]
    | p1::_ -> let tail = points
                       |> List.pairwise
                       |> List.filter (fun (p1: SensorItem, p2) -> p2.Timestamp - p1.Timestamp > TimeSpan.Zero)
                       |> List.map (fun (_, p) -> p)

               p1::tail
```

Мы воспользовались *сопоставлением с образцом* (pattern matching). Конструкция `match points with` похожа на `switch` в таких языках, как C/C++/Java/C#, но богаче.

В случае, если мы получем пустой массив (образец `[]`), функция возвращает пустой список. Если список содержит один элемент (образец `[p]`), мы снова возвращаем тот же самый список.

В других случаях мы берём точки списка попарно (функция `List.pairwise`), и оставляем только те пары, в которые дата и время второй точки больше, чем первой (функция `List.filter`). Наконец, мы выбрасываем первую точку из каждой пары. У нас остаётся список точек, начиная со второй, с правильной меткой времени.

Операция `|>` называется композицией функций. `x |> f |> g |> h` означатет в классической записи `h(g(f(x)))`. Вторая особенность, которая не бросилась вам в глаза, если вы не функциональный программист, это *каррирование*. Функции `List.filter` и `List.map` получают по два параметра. Первый мы записываем при вызове функции, но на самом деле мы не вызываем функцию. Мы создаём новую, с фиксированным первым параметром, которая всё ещё ожидает второго, чтобы выполниться.

В результате наш код читается так: 1) берём список точек (`points`); 2) составляем из них пары (`List.pairwise`); 3) отбрасываем те, которые не удовлетворяют условию; и 4) из каждой пары оставляем только второй элемент.

Запустим тесты. Сейчас проходят все три, значит, мы написали корректную функцию.

Напишем последний, четвёртый тест, который будет проверять, что функция не удаляет лишних элементов.

```ocaml
[<Fact>]
let ``removeZeroOrNegativeTimespans - with positime timespans - returns same list`` () =
    let source = [SensorItem(0.0, 0.0, 0.0, 0.0, DateTimeOffset.Parse("2018-12-07T16:38:14+03:00"));
                  SensorItem(1.0, 1.0, 0.0, 0.0, DateTimeOffset.Parse("2018-12-07T16:38:15+03:00"));
                  SensorItem(2.0, 2.0, 0.0, 0.0, DateTimeOffset.Parse("2018-12-07T16:38:16+03:00"))]

    let actual = removeZeroOrNegativeTimespans source

    let expected = [SensorItem(0.0, 0.0, 0.0, 0.0, DateTimeOffset.Parse("2018-12-07T16:38:14+03:00"));
                    SensorItem(1.0, 1.0, 0.0, 0.0, DateTimeOffset.Parse("2018-12-07T16:38:15+03:00"));
                    SensorItem(2.0, 2.0, 0.0, 0.0, DateTimeOffset.Parse("2018-12-07T16:38:16+03:00"))]
    Assert.Equal<seq<SensorItem>>(expected, actual)
```

### Внезапный подводный камень

Предложенный алгоритм неплохо работал до апреля 2019 года. В один прекрасный день он стал возвращать гигантские отрицательные результаты. Заглянув в *сырые данные* мы обнаружили странные даты.

|**№**|    **Широта**    |   **Долгота**    |  **Метка времени**  |
|-----|------------------|------------------|---------------------|
|  1  | 55,6700525       | 37,4681227       | 2019-04-17 11:07:26 |
|  2  | 55,6700947601348 | 37,4682662263513 | 1999-09-01 11:07:32 |
|  3  | 55,6700855400413 | 37,46821526438   | 1999-09-01 11:07:42 |
|  4  | 55,6699361       | 37,4682669       | 2019-04-17 11:07:41 |
| ... | ...              | ...              | ...                 |
| 721 | 55,7126607466489 | 37,4804087541997 | 1999-09-01 11:55:19 |
| 722 | 55,7126877782866 | 37,4804472271353 | 1999-09-01 11:55:21 |

Видите, что происходит? Время неожиданно уходит из 2017-го года в 1999-й и мы получаем несколько точек подряд из прошлого. Метка времени у этих точек продолжает возрастать, поэтому наш алгоритм выбрасывает вторую точку, но оставляет третью.

Причина произошедшенго оказалась нетривиальной. Нам &laquo;повезло&raquo;, мы наткнулись на смену эпох, заложенную в стандарте GPS. *Началом времён* он считает полночь с 5 на 6 января 1980 года. Дата и время GPS хранятся в двух целых числах: сначала порядковый номер недели, на который отведено 10 бит, затем количество секунд, прошедших с начала недели. 

Нетрудно заметить, что счётчик недель переполняется каждые 7168 дней (7&times;1024), или один раз в 19,62 лет. Апрель 2019-го&nbsp;&mdash; время очередного переполнения. Устройства, сделанные не совсем по стандарту, могут отбрасывать дату на 19 лет назад.

Чтобы исправить ситуацию, я применил два способа. Один из них основан на специальной обработке рискованных дат, и не очень интересен. Второй касается нашей функции. Её необходимо переписать так, чтобы она удаляла *все* метки из прошлого.

Для начала напишем тест для проверки новой ошибки.

```ocaml
[<Fact>]
let ``removeZeroOrNegativeTimespans - with two negative timespans - removes both points`` () =
    let source = [SensorItem(0.0, 0.0, 0.0, 0.0, DateTimeOffset.Parse("2018-12-07T16:38:15+03:00"));
                  SensorItem(1.0, 1.0, 0.0, 0.0, DateTimeOffset.Parse("2018-11-07T16:38:16+03:00"));
                  SensorItem(2.0, 2.0, 0.0, 0.0, DateTimeOffset.Parse("2018-11-07T16:38:17+03:00"));
                  SensorItem(3.0, 3.0, 0.0, 0.0, DateTimeOffset.Parse("2018-12-07T16:38:18+03:00"))]

    let actual = removeZeroOrNegativeTimespans source

    let expected = [SensorItem(0.0, 0.0, 0.0, 0.0, DateTimeOffset.Parse("2018-12-07T16:38:15+03:00"));
                    SensorItem(3.0, 3.0, 0.0, 0.0, DateTimeOffset.Parse("2018-12-07T16:38:18+03:00"))]
    Assert.Equal<seq<SensorItem>>(expected, actual)
```

Мы добавили в список две точки из прошлого подряд, и ожидаем, что наш методы удалит обе.

Мы уже не можем воспользоваться встроенной функцией `List.pairwise`, нам нужно написать фильтрацию самостоятельно.

```ocaml
let removeZeroOrNegativeTimespans points =
    let rec filter (p1: SensorItem) points =
        match points with
        | (p2: SensorItem)::tail -> if p2.Timestamp - p1.Timestamp > TimeSpan.Zero
                                    then p2::filter p2 tail
                                    else filter p1 tail
        | _ -> points

    match points with
    | p1::tail -> p1::filter p1 tail
    | _ -> points
```

В этом коде мы написали внутреннюю рекурсивную функцию `filter`. Мы постоянно передаём начкльную точку для сравнения. Если вторая точка удовлетворяет фильтру, мы используем её вместо начальной, а если нет, продолжаем использовать начальную.

После такой модификации кода у нас проходит и новый тест, и четыре предыдущих. Это означает, что мы не внесли ошибок в работающий код.