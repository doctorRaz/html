---
title: Сборник занимательных задач по языку программирования C, часть I
---
## Часть II

### Кодогенерация

#### Задача

Какие в C есть способы вывести на экран 100 (1000, 1000000) строк `"Hello, world!\n"`, не используя цикл и рекурсию?

#### Обсуждение

Первое решение задачи связано с использованием макроопределений:

```C
#define DO_10_TIMES(x) { x; x; x; x; x; x; x; x; x; x; }
#define DO_100_TIMES(x) DO_10_TIMES(DO_10_TIMES(x))

void main(void)
{
  DO_100_TIMES(std::cout << "Hello, world!\n");
}
```

Таким образом можно организовать генерацию повторяющегося кода.

Во втором решении мы воспользуемся тем, что при создании массива объектов, для каждого объекта вызывается конструктор. Следующий код будет делать то, что нам нужно, без явного использования цикла:

```c++
class Foo
{
public:
  Foo() { std::cout << "Hello, world!\n"; }
};

void main(void)
{
  Foo foos[100];
}
```

Поскольку автоматически вызывается не только конструктор, но и деструктор, мы можем уменьшить размер нашего массива вдвое:

```c++
class Foo
{
public:
  Foo() { std::cout << "Hello, world!\n"; }
  ~Foo() { std::cout << "Hello, world!\n"; }
};

void main(void)
{
  Foo foos[50];
}
```

Строго говоря, эти два примера не являются кодогенерацией, тем не менее, они удачно демонстрируют возможности С++.

Однако примеры с повторяющимся кодом не так интересны. Ниже приведён код, в котором с помощью шаблонов осуществляется кодогенерация для вычисления чисел Фибоначчи:

```c++
template<int N>
class Fibonacci
{
public:
  inline static int getValue(void) {
    return Fibonacci<N - 1>::getValue() + Fibonacci<N - 2>::getValue();
  }
};

template<> 
class Fibonacci<1>
{
public:
  inline static int getValue(void) {
    return 1;
  }
};

template<>
class Fibonacci<2>
{
public:
  inline static int getValue(void) {
    return 1;
  }
};

. . .

int fibonacci10 = Fibonaccy<10>::getValue();
```

Особо интересным в данном случае является то, что компилятор осуществляет все вычисления на стадии компиляции. Поскольку мы оформили код в виде встраиваемых (inline) функций,
у компилятора есть возможность развернуть их вызовы в константное выражение и сразу его вычислить.
Наша задача с помощью шаблонов может быть решена, например, так:

```c++
template<int N>
inline void printHelloWorld()
{
  printHelloWorld<N/10>();
  printHelloWorld<N/10>();
  printHelloWorld<N/10>();
  printHelloWorld<N/10>();
  printHelloWorld<N/10>();
  printHelloWorld<N/10>();
  printHelloWorld<N/10>();
  printHelloWorld<N/10>();
  printHelloWorld<N/10>();
  printHelloWorld<N/10>();
}

template<>
inline void printHelloWorld<1>()
{
    std::cout << "Hello, World!\n";
}

. . .

printHelloWorld<1000>();
```

### Макроопределения

#### Задача

Обсуждаем тонкое место в макроопределениях, о котором обычно не упоминают (позже я встретил его описание в литературе, но на момент создания статьи упоминаний о ней не было — примечание 2006г.)
В языке Паскаль существует строгое, но сложное правило расстановки точки с запятой (её нельзя ставить перед `else` и можно не ставить перед `end`). В языке Си с этим несколько проще, поскольку точку с запятой нужно ставить всегда, кроме составных операторов, заключённых в фигурные скобки.
Да?
Обсуждение
/* Переменные a и b обмениваются значениями... */
#define swap(a,b) { a = a - b; b = a + b; a = b - a; }

if(a > b)
	swap(a, b);
else
	a++, b++;
Этот кусок, кода не будет даже компилироваться, так как после обработки препроцессором приобретает следующий вид:
if(a > b)
	{ a = a - b; b = a + b; a = b - a; };
else
	a++, b++;
Если вы заметили, после закрывающей фигурной скобки стоит точка с запятой. Это означает, что между if и else находится два оператора: один — составной, ограниченный фигурными скобками, а другой — пустой, завершающийся точкой с запятой. Такое использование if не соответствует синтаксису языка Си и компилятор выдаст в этом месте ошибку.
В результате оказывается, что здесь после swap ставить точку с запятой не надо. Можно было бы в очередной раз посетовать на препроцессор, однако, существует способ обойти эту проблему. Определение swap должно быть записано так:
/* Переменные a и b обмениваются значениями... */
#define swap(a,b) do { a = a - b; b = a + b; a = b - a; } while(false)

if(a > b)
	swap(a, b);
else
	a++, b++;
Не правда ли, шикарное решение?
