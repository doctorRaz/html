---
title: Сборник занимательных задач по языку программирования C, часть I
---
## Часть II

Малоизвестные и непристойные особенности языков программирования C и C++.


### Кодогенерация

#### Задача

В давние времена для того, чтобы повторить одну и ту же операцию разработчики языков придумали *цикл* и *рекурсию*.
А можно ли в C и C++ вывести на экран 100 (1000, 1000000, &hellip;) строк `"Hello, world!\n"`, не используя цикл и рекурсию?

#### Обсуждение

Первое решение задачи связано с использованием макроопределений:

```C
#define DO_10_TIMES(x) { x; x; x; x; x; x; x; x; x; x; }
#define DO_100_TIMES(x) DO_10_TIMES(DO_10_TIMES(x))

void main(void)
{
  DO_100_TIMES(std::cout << "Hello, world!\n");
}
```

Таким образом можно организовать генерацию повторяющегося кода.

Во втором решении мы воспользуемся тем, что при создании массива объектов, для каждого объекта вызывается конструктор. Следующий код будет делать то, что нам нужно, без явного использования цикла:

```c++
class Foo
{
public:
  Foo() { std::cout << "Hello, world!\n"; }
};

void main(void)
{
  Foo foos[100];
}
```

Поскольку для объектов класса вызывается не только конструктор, но и деструктор, мы можем уменьшить размер массива вдвое:

```c++
class Foo
{
public:
  Foo() { std::cout << "Hello, world!\n"; }
  ~Foo() { std::cout << "Hello, world!\n"; }
};

void main(void)
{
  Foo foos[50];
}
```

Строго говоря, эти два примера не являются кодогенерацией, тем не менее, они удачно демонстрируют возможности С++.

Примеры с повторяющимся кодом не так интересны. Ниже приведён код, в котором с помощью шаблонов осуществляется кодогенерация для вычисления чисел Фибоначчи:

```c++
template<int N>
class Fibonacci
{
public:
  inline static int getValue(void) {
    return Fibonacci<N - 1>::getValue() + Fibonacci<N - 2>::getValue();
  }
};

template<> 
class Fibonacci<1>
{
public:
  inline static int getValue(void) {
    return 1;
  }
};

template<>
class Fibonacci<2>
{
public:
  inline static int getValue(void) {
    return 1;
  }
};

. . .

int fibonacci10 = Fibonaccy<10>::getValue();
```

Особо интересным в данном случае является то, что компилятор осуществляет все вычисления на стадии компиляции. Поскольку мы оформили код в виде *встраиваемых* (inline) функций,
у компилятора есть возможность развернуть их вызовы в константное выражение и сразу его вычислить. Важной частью решения является возможность *специализации шаблонов* в C++.

Исходная задача с помощью специализации шаблонов может быть решена так:

```c++
template<int N>
inline void printHelloWorld()
{
  printHelloWorld<N/10>();
  printHelloWorld<N/10>();
  printHelloWorld<N/10>();
  printHelloWorld<N/10>();
  printHelloWorld<N/10>();
  printHelloWorld<N/10>();
  printHelloWorld<N/10>();
  printHelloWorld<N/10>();
  printHelloWorld<N/10>();
  printHelloWorld<N/10>();
}

template<>
inline void printHelloWorld<1>()
{
  std::cout << "Hello, World!\n";
}

. . .

printHelloWorld<1000>();
```

### Макроопределения

#### Задача

В языке Pascal существует строгое, но сложное правило расстановки точки с запятой (её нельзя ставить перед `else` и можно не ставить перед `end`). В языке C с этим несколько проще,
поскольку точку с запятой нужно ставить всегда, кроме составных операторов, заключённых в фигурные скобки.

Да?

#### Обсуждение

```c
/* Переменные a и b обмениваются значениями. */
#define swap(a,b) { a = a - b; b = a + b; a = b - a; }

if(a > b)
  swap(a, b);
else
  a++, b++;
```

Этот кусок, кода не будет даже компилироваться, так как после обработки препроцессором приобретает следующий вид:

```c
if(a > b)
  { a = a - b; b = a + b; a = b - a; };
else
  a++, b++;
```

Если вы заметили, после закрывающей фигурной скобки стоит точка с запятой. Это означает, что между `if` и `else` находится два оператора: один — составной, ограниченный фигурными скобками,
а другой — пустой, завершающийся точкой с запятой. Такое использование `if` не соответствует синтаксису языка C и компилятор считает этот код ошибочным.

Здесь не надо ставить точку с запятой после `swap`, но код без разделителя выглядит неправильно:

```c
if(a > b)
  swap(a, b)
else
  a++, b++;
```

Можно было бы в очередной раз посетовать на препроцессор, однако, существует способ обойти эту проблему. Определение `swap` может быть записано так:

```c
/* Переменные a и b обмениваются значениями. */
#define swap(a,b) do { a = a - b; b = a + b; a = b - a; } while(false)

if(a > b)
  swap(a, b);
else
  a++, b++;
```

Тело цикла `do/while` будет выполнено только один раз, при этом цикл является отдельным оператором, который требует точки с запятой.

### Программа, которая печатает свой исходный код

#### Задача

Насколько мне известно, первым, кто предложил эту задачу, был [Уозерелл](https://www.ozon.ru/context/detail/id/1940685/). Затем, несколько лет назад, она упоминалась
в журнале &laquo;Наука и Жизнь&raquo; и там же сообщалось, что решить ее можно на любом языке &laquo;достаточно высокого уровня&raquo;.

Докажите, что C&nbsp;&mdash; язык &laquo;достаточно высокого уровня&raquo;, напишите программу, честно распечатывающую саму себя. Под &laquo;честностью&raquo; понимаются
следующие условия:

1. нельзя вызывать функции чтения;
2. нельзя пользоваться особенностями операционной системы, компилятора и т.д.

Написав эту программу, вы откроете в C еще неведомые вам стороны. Те же, кто в свое время уже решил эту задачку могут сравнить мое решение со своим.

#### Обсуждение

Текст программы надо где-то брать. Чтение с внешних накопителей
запрещено, поэтому он должен хранится в самой программе. Как лучше всего
хранить текст? Интуиция подсказывает, что оптимальным здесь будет массив
строковых констант:
```c
#include <stdio.h>                      /* 1 */
char *line[] =                          /* 2 */
{                                       /* 3 */
  "строка 1",
  ...,
  "строка N",
};                                      /* 4 */
строка 5                                /* 5 */
...                                     /* 6 */
строка N                                /* 7 */
```

Примечание:  справа  в  комментариях  указаны  номера  строк, список
строковых констант в нумерацию не включён.

Распечатать программу можно, используя  цикл `for`, однако в  выходном
потоке не будут присутствовать строковые константы.  Для того чтобы выдать и их  тоже
необходимо записать в выходной поток два пробела, открывающую кавычку, `line[i]`,
закрывающую кавычку, запятую и символ новой строки.  Нельзя,
однако, использовать литеры '\\' и '\"' (подумайте, почему), поэтому табуляцию 
и кавычку придется выдавать, как символы 9 и 34 (для ASCII). Это - единственная 
непереносимость.

        Вот  доведенный  текст  программы.  Для машин с другой  (не  ASCII)
кодировкой,  вам  необходимо  будет  поменять  значения  констант  `NEW_LINE`, 
`QUOTE` и `TAB` (не только в  тексте  программы,  но и в  массиве `line`).
`fputc`  и  `fputs`  используются  вместо  `putchar`  и `puts`, так как `puts`
выдает литеру  "новая строка",  что (см.  программу) не  везде нужно,  поэтому
приходится  вызывать  `fputs`.  Чтобы  как-то  объединообразить программу, все
остальные вызвы `putchar` и `puts` я заменил на `fputc` и `fputs`.
──────────────────────────────────────────────────────────────────────────────
#include <stdio.h>

char *line[] =
{
        "#include <stdio.h>",
        "",
        "char *line[] =",
        "{",
        "};",
        "",
        "/*коды ASCII (дабы не использовать кавычку и неделить)*/",
        "#define NEW_LINE        10      /*новая строка*/",
        "#define QUOTE           34      /*кавычка*/",
        "#define TAB             9       /*табуляция*/",
        "#define I",
        "",
        "int main()",
        "{",
        "I       int i, j;",
        "I       for(i = 0; i < 4; i++)          /*пишем строки: #include*/",
        "I       {                               /*и char *line[] = {*/",
        "I       I       fputs(line[i], stdout);",
        "I       I       fputc(NEW_LINE, stdout);",
        "I       }",
        "I       for(j = 0; NULL != line[j]; j++)/*пишем текст программы,*/",
        "I       {                               /*как стринги:*/",
        "I       I       fputc(TAB, stdout);     /*табуляция*/",
        "I       I       fputc(QUOTE, stdout);   /*кавычка*/",
        "I       I       fputs(line[j], stdout); /*сама строка*/",
        "I       I       fputc(QUOTE, stdout);   /*закрывающая кавычка*/",
        "I       I       fputc(',', stdout);     /*запятая*/",
        "I       I       fputc(NEW_LINE, stdout);",
        "I       }",
        "I       fputc(TAB, stdout);             /*пишем NULL*/",
        "I       fputc('N', stdout);",
        "I       fputc('U', stdout);",
        "I       fputc('L', stdout);",
        "I       fputc('L', stdout);",
        "I       fputc(NEW_LINE, stdout);",
        "I       for(; NULL != line[i]; i++)     /*после записи*/",
        "I       {                               /*стрингов продолжаем*/",
        "I       I       fputs(line[i], stdout); /*писать текст*/",
        "I       I       fputc(NEW_LINE, stdout);/*программы*/",
        "I       }",
        "I       return 0;",
        "}",
	NULL
};

/*коды ASCII (дабы не использовать кавычку и неделить)*/
#define NEW_LINE	10	/*новая строка*/
#define QUOTE           34      /*кавычка*/
#define TAB             9       /*табуляция*/
#define I

int main()
{
I       int i, j;
I       for(i = 0; i < 4; i++)          /*пишем строки: #include*/
I       {                               /*и char *line[] = {*/
I       I       fputs(line[i], stdout);
I       I       fputc(NEW_LINE, stdout);
I       }
I       for(j = 0; NULL != line[j]; j++)/*пишем текст программы,*/
I       {                               /*как стринги:*/
I       I       fputc(TAB, stdout);     /*табуляция*/
I       I       fputc(QUOTE, stdout);   /*кавычка*/
I       I       fputs(line[j], stdout); /*сама строка*/
I       I       fputc(QUOTE, stdout);   /*закрывающая кавычка*/
I       I       fputc(',', stdout);     /*запятая*/
I       I       fputc(NEW_LINE, stdout);
I       }
I       fputc(TAB, stdout);             /*пишем NULL*/
I       fputc('N', stdout);
I       fputc('U', stdout);
I       fputc('L', stdout);
I       fputc('L', stdout);
I       fputc(NEW_LINE, stdout);
I       for(; NULL != line[i]; i++)     /*после записи*/
I       {                               /*стрингов продолжаем*/
I       I       fputs(line[i], stdout); /*писать текст*/
I       I       fputc(NEW_LINE, stdout);
I       }
I       return 0;
}
──────────────────────────────────────────────────────────────────────────────
        Быть может, при сравнении файлов (исходного и полученного) вы
получите разницу уже в размерах, не говоря уж о содержимым. Это произошло из-
за того, что ваш текстовый редактор (с помощью которого вы вытаскивали пример
из этого текста) при сохранении заменил табуляциями пробелами. Достаточно 
откомпилировать сгенерированный файл - и все последующие файлы будут совпадать 
с ним досимвольно.
