# Часть I

## Приоритеты операторов

### Задача

Многие программисты используют свой компьютер для очень странных вещей. Например, для того, чтобы принять решение, они пишут программу, которая случайным образом печатают слова «орел» и «решка» — и это вместо того, чтобы бросить монетку. Если вы долго писали на Си, а теперь решили изучить Си++, вас несомненно посетит вопрос: а стоит ли это делать? Действительно ли Си++ лучше, чем Си? Мы не будем отдавать решение этого вопроса на откуп слепого случая, а станем придерживаться строгой логики.

Мы напишем такую программу:

```c
#include <stdio.h>

void main()
{
  int C = 0;
  puts("Учить ли Си++?");

  if(C > C++)
    puts("Не учить.");
  else if (C == C++)
    puts("Не знаю.");
  else
    puts("Учить");
}
```

Теперь, не запуская программу, попытайтесь ответить на поставленный вопрос.

<details>
<summary><h3>Обсуждение</h3></summary>

Посмотрев в таблицу «приоритеты и порядок разбора операторов» (приложение А), находим, что операторы `&lt;`, `==` и `&gt;`, разбираются слева направо. Это должно приводить к результату «Не знаю». А теперь запустите программу и проверьте.

Если вы работаете на PC и используете один из общеизвестных компиляторов, то, вероятнее всего, увидите ответ «Не учить». Почему?

Дело здесь в одной тонкости, о которой знают, вероятно, только те, кто сам писал компиляторы. Керниган и Ритчи упоминают о ней настолько вскользь, что она даже не фиксируется. Рассмотрим, например, выражение `x + y + z`, где `x`, `y` и `z` тоже являются выражениями. Порядок разбора (ассоциативность) оператора `+`, согласно таблице гарантирует разбор слева направо, то есть так: `(x + y) + z`.

Но он не гарантирует, что выражение `x` будет вычисляться раньше, чем `z`! Порядок вычисления операндов разработчики компилятора вольны выбирать по своему усмотрению. Это означает, что в нашей задаче C++ может быть вычислено раньше C, а может быть и позже. Интересно, что даже один и тот же компилятор в состоянии выдавать разные результаты, например, в отладочной и оптимизированной версиях программы.

Кстати, операнды операторов чаще всего вычисляются именно справа налево, по крайней мере, при отключенной оптимизации. Так происходит потому, что арифметические выражения  вычисляют через стек, например, для выражения `x + y + z` нужно вычислить и положить в стек `z`,
`y` и `x`, а затем два раза сложить значения, находящиеся на вершине стека.

Примечание: порядок выполнения гарантируется стандартом только для операторов: `&amp;&amp;`, `||` и «запятая».
</details>

## Символьные константы

### Задача

Вам предлагается узнать, не прибегая к помощи компилятора, что будет выдано на экран в результате выполнения этого кода:

```c
printf("Буква \0x41\n");
```

В ASCII символ с кодом 0x41 — это буква A английского алфавита. Из этого и исходите.

<details>
<summary><h3>Обсуждение</h3></summary>

Вы, конечно, слышали страшные истории о том, что одна пропущенная запятая в миллионострочной программе отклоняла спутник Земли от курса, взрывала реактор и т.д. и т.п. В данном случае последствия не столь ужасны, да и дело не в пропущенной запятой, а в лишнем символе `0`. Возможно, вы сразу поняли, где здесь собака зарыта, для тех же, кто еще не понял, привожу ответ: будет напечатана строчка "Буква " (последний символ — пробел). Записи `0x41` и `\x41` похожи, так что можно случайно приписать лишний `0` там, где этого делать не нужно.
Запись `"\0x41"` интерпретируется компилятором как `{'\0', 'x', '4', '1'}`, и строка `"Буква \0x41\n"` будет заканчиваться там, где компилятор встретит символ `\0`.

Эту ошибку мы искали вдвоём в течение полутора часов — при взгляде мельком запись выглядит совершенно естественно.
</details>

Метки
Задача
Вот пример программы:
switch (i)
{
case 0:
        puts("Zero");
        break;
case 1:
        puts("One");
        break;
case 2:
        puts("Two");
        break;
defualt:
        puts("I don't know");
        break;
}
Как этот код будет работать при различных i?
Обсуждение
"I don't know" никогда не напечатается — это мёртвый код. В K&R написано: «Если выяснилось, что ни одна из констант не подходит, то выполняется ветвь, помеченная словом default, если таковая имеется, в противном случае ничего не делается.» (стр.63) В том, что ветви default в приводимом примере нет, можно убедиться, внимательно перечитав листинг. Для самых невнимательных сообщаю: в программе присутствует только метка defualt. 
Поразительно! Ни одного предупреждающего сообщения от компилятора, ни одной ошибки, ничего! А программа не работает. Вы скажете: хороший компилятор несомненно укажет на мертвый код или метку, на которую не ссылается ни один goto. Но неплохой Microsoft C 5.10 так ни разу и не ругнулся на этот пример.
В данном случае злую шутку играет тот самый замыленый глаз. Эта ошибка встречалась в реальной программе и потребовала несколько часов напряжённого поиска.
Комментарии
Задача
Перед вами пример программы, которая вычисляет значение π5.
#include <stdio.h>

#define PI 3.1415926535897932385

void main(void)
{
    int i;
    double d = 1.0;
                                /*************************
    for(i = 0; i < 5; i++)      ** Здесь вычисляется Пи **
        d *= PI;                ** в пятой степени      **
                                *************************/
    printf("Пи в степени %d равно %lf\n", i, d);
}
Как вы думаете, чему равно Пи в степени 5?
Обсуждение
С каких это пор Пи в пятой степени равно 1?
В этом примере ошибка чисто психологического плана — все дело в этой самой рамочке комментария. Вы видите справа комментарий и вам кажется, что рамка его со всех сторон ограничивает. Однако, K&R утверждает, что комментарии ограничиваются только символами /* и */, и ничем больше. Следовательно, строчки:
for(i = 0; i < 5; i++)
    d *= PI;
так же будут закомментированы.
Этот пример не надуманный, в свое время я таким образом закомментировал часть структуры. Информация для размышления: пи в пятой степени равно 306,018392.
Инкремент, декремент…
Задача
Как разбирается инструкция ++i++: так — ++(i++) или так — (++i)++?
Если i == 0, то чему будет равно значение выражения ++i++?
Обсуждение
Удивительно, но даже опытные программисты на Си очень плохо представляют себе над чем те или иные операторы выполняются. Например, ++ и -- могут выполняться только над Л-значениями. Л-значение — это любое выражение, которое можно написать в левой часть оператора присваивания, т.е. любой объект, который имеет адрес и не является константным.
В приложении к задаче, это означает, что выражение ++i++ так же бессмысленно, как и ++i = i + 1. Эта инструкция вообще не будет компилироваться, и вы получите ошибку «требуется Л-значение» (L-value required). У Страустрапа очень хорошо и подробно описаны Л-значения, рекомендую за справками обращаться именно к нему.
Инкремент, декремент… (продолжение)
Задача
Что вы можете сказать об инструкции -i++?
Обсуждение
Эта инструкция имеет одно важное отличие от предыдущей, а именно: операнд унарного минуса не обязан быть Л-значением. Т.е. весь вопрос сводится к тому, как компилятор ее представляет: в виде (-i)++ или -(i++)?
Посмотрев в ближайшую таблицу приоритетов и порядка разбора операторов, видим, что унарный минус и инкремент находятся во второй строчке, там же указано, что они разбираются справа налево. Следовательно сначала будет выполняться оператор ++, а затем — унарный минус.
Ответ: это выражение будет принято компилятором. Значение этого выражения равно -(i + 1).
Аргументы командной строки
Задача
Представим, что шапка функции main выглядит так:
int main(int foo, char **bar)
Как вы думаете, будут ли выполнять foo и bar роль стандартных argc и argv?
Обсуждение
Многие отвечают так: «в принципе должны, но вообще-то не знаю». Всё верно: вообще-то должны. Обратившись к K&R, находим: «В момент вызова main получает два аргумента. В первом, обычно называемом argc (сокращение от argument count)…» (стр.113). Далее продолжать не имеет смысла — ясно, что стандарт ANSI не оговаривает названия аргументов функции main, следовательно, foo и bar будут работать не хуже, чем argc и argv.
О способах сжатия программ на языке программирования Си
Задача
Однажды мы с моим другом Булатом Зиганшиным обсуждали процесс архивации. Я предположил, что если архиватор знает, что файл — это текст программы на языке Си, он может сжимать его сильнее. Например, инструкция while всегда записывается так:
while (условное выражение)
	оператор
Впрочем, если вспомнить стандарт, то окажется, что в любом месте, где можно написать пробел, можно написать и комментарий:
while /* комментарий */ (условное выражение)
	оператор
или даже так:
while
// комментарий
(условное выражение)
	оператор
В любом случае, сразу после инструкции while следует ноль или больше пробельных литер, либо комментарии, и затем условное выражение в скобках. Владея этой информацией, архиватор мог бы не хранить круглые скобки.
Эти рассуждения правдоподобны.
Предположим, что вы решили написать такой архиватор. Действительно ли это возможно? Есть ли другие способы записи инструкции while, не описанные выше? 
Обсуждение
Не буду вас долго мучить, вот программка:
while
#include "foo.h"
{
	. . .
}
Файл foo.h может выглядеть так:
(условное выражение)
Именно это и ответил мне Булат на все мои выкладки.
Дима Борток предложил другое решение этой задачи:
#define condition (x < 3)
while condition
{
	. . .
}
#include
Задача
Задача похожа на предыдущую. Возможны ли другие записи директивы #include, кроме приведённых?
#include "foo.h"
#include <bar>
Обсуждение
Конечно, и здесь не обошлось без макроопределений:
#ifdef WIN
	#define IO "winio.h"
#else
	#define IO <stdio.h>
#endif

#include IO
Интересно, что пример подобного использования не описан в K&R, тем не менее, он присутствует в «Рабочем проекте» комитета X3J11. Параметризация включаемых файлов иногда необходима, а такой метод не вносит дополнительной путаницы и разрешен многими существующими компиляторами, поэтому он включен в стандарт ANSI.
for
Задача
Оптимизируйте по скорости следующий код:
int i;
for(i = 0; i < 10; i++);
Обсуждение
Это — задачка-шутка (я действительно не понимаю смысл оптимизации пустого цикла). Она имеет не очень прямое отношение к Си и приведена здесь просто для разрядки. Ответ таков:
int i = 10;
Макроопределения
Задача
Здесь нет традиционного коварного вопроса. Вместо этого обсуждается одно тонкое место в макроопределениях, о котором, обычно, не упоминают (в действительности, я уже встречал описание этой тонкости в литературе, но на момент написания статьи упоминаний о ней не было — позднее примечание 2006г.)
В языке Паскаль существует строгое, но сложное правило расстановки точки с запятой (её нельзя ставить перед else и можно не ставить перед end). В языке Си с этим несколько проще, поскольку точку с запятой нужно ставить всегда, кроме составных операторов, заключённых в фигурные скобки.
Да?
Обсуждение
/* Переменные a и b обмениваются значениями... */
#define swap(a,b) { a = a - b; b = a + b; a = b - a; }

if(a > b)
	swap(a, b);
else
	a++, b++;
Этот кусок, кода не будет даже компилироваться, так как после обработки препроцессором приобретает следующий вид:
if(a > b)
	{ a = a - b; b = a + b; a = b - a; };
else
	a++, b++;
Если вы заметили, после закрывающей фигурной скобки стоит точка с запятой. Это означает, что между if и else находится два оператора: один — составной, ограниченный фигурными скобками, а другой — пустой, завершающийся точкой с запятой. Такое использование if не соответствует синтаксису языка Си и компилятор выдаст в этом месте ошибку.
В результате оказывается, что здесь после swap ставить точку с запятой не надо. Можно было бы в очередной раз посетовать на препроцессор, однако, существует способ обойти эту проблему. Определение swap должно быть записано так:
/* Переменные a и b обмениваются значениями... */
#define swap(a,b) do { a = a - b; b = a + b; a = b - a; } while(false)

if(a > b)
	swap(a, b);
else
	a++, b++;
Не правда ли, шикарное решение?
Макроопределения и шаблоны
Задача
Ниже приведён пример совместного использования макроопределения и шаблона. Будет ли работать такая конструкция?
#define isPositive(value1, value2) (value1 > 0)?(value2):(0)

template<int N, int M> int sum() { return N + M; }

. . .

std::cout << isPositive(sum<2, 3>(), 10);
Обсуждение
Такая конструкция не будет даже компилироваться. Компилятор выдаст ошибку о неверном числе параметров макроопределения. Препроцессор не понимает, что sum<2, 3>() является неделимой синтаксической конструкцией, и интерпретирует запятую, как разделитель параметров макроопределения. Так происходит потому, что угловые скобки в Си++ имеют двойной смысл, и для того, чтобы правильно разобрать выражение foo<const1, const2>(var1), необходимо иметь информацию о том, что foo является шаблоном. Этой информацией владеет компилятор, а у препроцессора её нет.
Обращу особое внимание, что foo<const1, const2>(var1) является синтаксически корректной конструкцией в Си и Си++, поскольку в данном случае мы имеем два выражения foo<const1 и const2>(var1), разделённые оператором «запятая».
Обойти проблему можно, поскольку круглые скобки воспринимаются препроцессором правильно (он не может судить о типе своих операндов, но в состоянии определять парность скобок). Эта строка будет компилироваться корректно:
std::cout << isPositive((sum<2, 3>()), 10);
Инкапсуляция
Задача
Теоретически, имея описание класса в заголовочном файле, мы можем обращаться к закрытым (private) членам по их смещению относительно начала класса:
foo.h:
class Foo
{
private:
    int a;
    int b;
};

. . .

Foo foo;
int *values = (int *)&foo;

values[0] = 1; // равносильно foo.a = 1;
values[1] = 2; // равносильно foo.b = 2;
Оставим сейчас в стороне вопрос о том, насколько это корректно с точки зрения принципов ООП, и подойдём к задаче исследовательски. Предложенный способ приводит к непереносимости, поскольку члены a и b могут выравниваться в классе не так, как это предполагаем мы, кроме того, если класс содержит виртуальные функции, в его начале хранится указатель на таблицу виртуальных функции. Мы можем решить эту задачу в принципе за счёт некоторых коэффициентов, но, к сожалению, они будут меняться от класса к классу и от компилятора к компилятору.
Существует ли возможность реализовать переносимый код в данном случае?
Обсуждение
Да, существует. Наиболее простой способ — воспользоваться препроцессором:
#define private public
#include "foo.h"

Foo foo;
foo.a = 1;
foo.b = 2;
Массивы
Задача
Предположим, вы переходите на Си с Паскаля и вместо непривычной инструкции a[i][j] пишите привычную a[i, j], например, в таком контексте:
printf("next = %d\n", a[i, j]);
Как на это прореагирует компилятор?
Обсуждение
Никак. В Си есть редко используемый (поэтому о нем так часто и забывают) оператор запятая «,». Фактически, этот код будет рассматриваться как
printf("next = %d\n", a[j]);
Компилятор мог бы обнаружить ошибку, если бы использование a[j] вместо a[i][j] приводило к несоответствию типов, но при вызове printf этого не происходит (см. подробности в K&R).
Кодогенерация
Задача
Какие в Си есть способы вывести на экран 100 (1000, 1 000 000) строк "Hello, world!\n", не используя цикл и рекурсию?
Обсуждение
И снова эта задача не на сметливость, а на знание тонких мест в Си и Си++. Первое решение задачи связано с использованием макроопределений.
#define DO_10_TIMES(x) { x; x; x; x; x; x; x; x; x; x; }
#define DO_100_TIMES(x) DO_10_TIMES(DO_10_TIMES(x))

void main(void)
{
	DO_100_TIMES(std::cout << "Hello, world!\n");
}
Таким образом можно организовать генерацию повторяющегося кода.
Во втором решении мы воспользуемся тем, что при создании массива объектов, для каждого объекта вызывается конструктор. Следующий код будет делать то, что нам нужно, без явного использования цикла:
class Foo
{
public:
	Foo() { std::cout << "Hello, world!\n"; }
};

void main(void)
{
	Foo foos[100];
}
Поскольку автоматически вызывается не только конструктор, но и деструктор, мы можем уменьшить размер нашего массива вдвое:
class Foo
{
public:
	Foo() { std::cout << "Hello, world!\n"; }
	~Foo() { std::cout << "Hello, world!\n"; }
};

void main(void)
{
	Foo foos[50];
}
Строго говоря, эти два примера не являются кодогенерацией, тем не менее, они удачно демонстрируют возможности Си++.
Однако примеры с повторяющимся кодом не так интересны. Ниже приведён код, в котором с помощью шаблонов осуществляется кодогенерация для вычисления чисел Фибоначчи:
template<int N>
class Fibonacci
{
public:
	inline static int getValue(void)
	{
		return Fibonacci<N - 1>::getValue() + Fibonacci<N - 2>::getValue();
	}
};

template<> 
class Fibonacci<1>
{
public:
	inline static int getValue(void)
	{
		return 1;
	}
};

template<>
class Fibonacci<2>
{
public:
	inline static int getValue(void)
	{
		return 1;
	}
};

. . .

int fibonacci10 = Fibonaccy<10>::getValue();
Особо интересным в данном случае является то, что компилятор осуществляет все вычисления на стадии компиляции. Поскольку мы оформили код в виде встраиваемых (inline) функций, у компилятора есть возможность развернуть их вызовы в константное выражение и сразу его вычислить.
Наша задача с помощью шаблонов может быть решена, например, так:
template<int N>
inline void printHelloWorld()
{
    printHelloWorld<N/10>();
    printHelloWorld<N/10>();
    printHelloWorld<N/10>();
    printHelloWorld<N/10>();
    printHelloWorld<N/10>();
    printHelloWorld<N/10>();
    printHelloWorld<N/10>();
    printHelloWorld<N/10>();
    printHelloWorld<N/10>();
    printHelloWorld<N/10>();
}

template<>
inline void printHelloWorld<1>()
{
    std::cout << "Hello, World!\n";
}

. . .

printHelloWorld<1000>();
