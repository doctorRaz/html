## Часть I

### Приоритеты операторов

#### Задача

Многие программисты используют свой компьютер для очень странных вещей: чтобы принять решение, они пишут программу, которая случайным образом печатает
«орел» и «решка» — вместо того, чтобы бросить монетку. Если вы долго писали на C, а теперь решили изучить C++, вас наверняка волнует, стоит ли это делать?
Правда, что C++ лучше, чем C? Мы не станем отдавать решение этого вопроса слепому случаю, а применим свой опыт программиста.

Мы напишем такую программу:

```c
#include <stdio.h>

void main()
{
  int C = 0;
  puts("Учить ли Си++?");

  if(C > C++)
    puts("Не учить.");
  else if (C == C++)
    puts("Не знаю.");
  else
    puts("Учить");
}
```

Теперь, не запуская код, скажите, что напечатает программа.

#### Обсуждение

Посмотрев в [таблицу приоритетов и порядка разбора операторов](a), узнаём, что операторы `<`, `==` и `>`, разбираются слева направо. Это должно приводить к результату «Не знаю».
А теперь запустите программу и проверьте.

Если вы работаете на PC и используете один из общеизвестных компиляторов, то, вероятно, увидите ответ «Не учить». Почему?

Потому что в этой программе значение имеет не то, в каком порядке выполняются операторы, а то, в каком порядке вычисляются их операнды. Рассмотрим выражение
`a * b + c * d + e * f`. Порядок разбора (ассоциативность) оператора `+`, согласно таблице гарантирует разбор слева направо, то есть так: `(a * b + c * d) + e * f`. Но ассоциативность
не влияет на то, в каком порядке будут вычислены значения выражений `a * b`, `c * d` и `e * f`. Если `e * f` вычисляется строкой выше, то компилятор хранит
результат произведения в регистре, поэтому использует его. `a * b` и `c * d` *могут* быть вычислены после `e * f`:

```c
int t3 = e * f;
int t1 = a * b;
int t2 = c * d;
int r = (t1 + t2) + t3;
```

Стандарт C утверждает, что порядок вычисления операндов не регламентирован, и разработчики компилятора вольны выбирать его по своему усмотрению. В нашей задаче C++ может быть вычислено раньше C,
а может быть и позже. Даже один и тот же компилятор может выдавать разные результаты при включенной и отключенной оптимизации.

Порядок вычисления операндов неважен, пока мы используем операторы без побочных эффектов, но такие операторы, как `++` и `-=` не только возвращают значение переменной, но и изменяют её. Если
переменная встречается в выражении несколько раз, невозможно предсказать, в каком месте возникнет её новое значение. Именно поэтому в C и C++ надо учитывать возможные побочные эффекты:

```c
// так писать можно
int i = 0;
while (i < n)
  a[i++] = value;

// так писать нельзя
int i = 0;
while (i < n - 1)
  a[i] = a[i++];

// надо переписать так
int i = 0;
while (i < n - 1) {
  a[i] = a[i + 1];
  i++;
}
```

В Java и C# операнды вычисляются слева направо, когда это возможно. В выражении `a(b(), c())` сначала будут вычислены методы `b` и `c`, а затем `a`, потому что ему требуются
значения `b` и `c`. Но даже в этих языках код надо писать так, чтобы он не вызывал вопросов у читателя, пришедшего из C и C++.

Есть только три оператора, для которых порядок вычисления операндов закреплён стандартом: `&&`, `||` и «запятая»:

```c
bool contains(const char* array, size_t length, char value)
{
  size_t i = 0;
  while (i < length && array[i++] != value)
    ;

  return i < length;
}
```

В этой функции `i` и `array[i++]` можно использовать в одном выражении, поскольку правый операнд оператора `&&` будет вычислена только в том случае, если левый операнд истинен.

### Символьные константы

#### Задача

Что будет выдано на экран в результате выполнения этого кода?

```c
printf("Буква \0x41\n");
```

В ASCII символ с кодом `0x41` — это буква 'A' английского алфавита. Из этого и исходите.

#### Обсуждение

Префикс `0x` означает, что целочисленная константа записана в шестнадцатиричной системе счисления. Но если мы хотим указать шестнадцатиричный код символа внутри строки,
нужен префикс `\x`. Запись `"Буква \0x41\n"` означает для компилятора `{'Б', 'у', 'к', 'в', 'а', ' ', '\0', 'x', '4', '1', '\n'}`. В статическую память программы будут помещены все 11
символов, но строковые функции стандартной библиотеки C интепретируют `'\0'` как конец строки, поэтому `printf` вывыдет только символы перед `'\0'`, то есть строку `"Буква "` с пробелом
на конце.

Эту ошибку мы искали вдвоём в течение полутора часов — при взгляде мельком запись выглядит вполне естественно.

### Метки

#### Задача

Функция `detect012` вызвана с параметром 3. Что будет напечатано на экране?

```c
void detect012(int i)
{
  switch (i)
  {
  case 0:
    puts("Zero");
    break;
  
  case 1:
    puts("One");
    break;
  
  case 2:
    puts("Two");
    break;
  
  defualt:
    puts("I don't know");
    break;
  }
}
```

#### Обсуждение

В K&R читаем:

> Если выяснилось, что ни одна из констант не подходит, то выполняется ветвь, помеченная словом `default`, если таковая имеется, в противном случае ничего не делается.
> *(стр.63)*

В том, что ветви `default` в приводимом примере нет, можно убедиться, внимательно перечитав листинг. В коде встречается метка `defualt`, в которой переставлены буквы 'u' и 'a'.

Это обычная опечатка, которую трудно увидеть замыленным глазом. В 1989 Microsoft C Compiler версии 5.10 не выдавал на этот код никаких предупреждений, и я потратил на поиск
ошибки несколько часов. Сейчас компиляторы стали дружелюбнее, и подсказывают, что на метку `defualt` нет ни одного перехода.

### Комментарии

#### Задача

Перед вами пример программы, которая должна вычислить значение $$\pi ^ 5$$. Она действительно это делает?

```
#include <stdio.h>

#define PI 3.1415926535897932385

void main(void)
{
  int i;
  double d = 1.0;
                              /*************************
  for(i = 0; i < 5; i++)      ** Здесь вычисляется Пи **
    d *= PI;                  ** в пятой степени      **
                              *************************/
  printf("Пи в степени %d равно %lf\n", i, d);
}
```

#### Обсуждение

В C комментарии ограничиваются символами `/*` и `*/`, поэтому всё, что окажется между ними, компилятор проигнорирует, в том числе и эти две строки:

```
for(i = 0; i < 5; i++)
  d *= PI;
```
Программа напечатает число `1`, которое конечно не равно $$\pi ^ 5$$, то есть `306,018392`.

Не смотря на то, что код кажется неправдоподобным, он встречался в реальной программе. Поняв, в чём дело, я для себя сделал вывод, что рамочки это конечно красиво,
но простота оформления кода гораздо важнее.

### Инкремент и декремент

#### Задача

Как разбирается инструкция `++i++`: так — `++(i++)` или так — `(++i)++`?
Если `i == 0`, то чему будет равно значение выражения `++i++`?

#### Обсуждение

Удивительно, но даже опытные программисты на C очень плохо представляют себе над чем те или иные операторы выполняются.
Например, `++` и `--` могут выполняться только над Л-значениями. Л-значение — это любое выражение, которое можно написать
в левой часть оператора присваивания, т.е. любой объект, который имеет адрес и не является константным.

В приложении к задаче, это означает, что выражение `++i++` так же бессмысленно, как и `++i = i + 1`. Эта инструкция вообще не будет
компилироваться, и вы получите ошибку «требуется Л-значение» (L-value required). У Страустрапа очень хорошо и подробно
описаны Л-значения, рекомендую за справками обращаться именно к нему.

### Унарные минус

#### Задача

Что вы можете сказать об инструкции `-i++`?

#### Обсуждение

Эта инструкция имеет одно важное отличие от предыдущей, а именно: операнд унарного минуса не обязан быть Л-значением. Т.е. весь вопрос
сводится к тому, как компилятор ее представляет: в виде `(-i)++` или `-(i++)`?

Посмотрев в ближайшую таблицу приоритетов и порядка разбора операторов, видим, что унарный минус и инкремент находятся во второй
строчке, там же указано, что они разбираются справа налево. Следовательно сначала будет выполняться оператор `++`, а затем —
унарный минус.

Ответ: это выражение будет принято компилятором. Значение этого выражения равно `-(i + 1)`.

### Аргументы командной строки

#### Задача

Функция `main` описана так:

```c
int main(int foo, char **bar)
```

Как вы думаете, будут ли выполнять `foo` и `bar` роль стандартных `argc` и `argv`?

#### Обсуждение

Многие отвечают так: «в принципе должны, но вообще-то не знаю». Всё верно: вообще-то должны. Обратившись к K&R, находим: «В момент
вызова `main` получает два аргумента. В первом, обычно называемом `argc` (сокращение от argument count)…» (стр.113). Далее продолжать
не имеет смысла — ясно, что стандарт ANSI не оговаривает названия аргументов функции `main`, следовательно, `foo` и `bar` будут
работать не хуже, чем `argc` и `argv`.

### О способах сжатия программ на языке программирования C

#### Задача

Однажды мы с моим другом Булатом Зиганшиным обсуждали процесс архивации. Я предположил, что если архиватор знает, что файл — это текст программы на языке Си, он может сжимать его сильнее. Например, инструкция while всегда записывается так:
while (условное выражение)
	оператор
Впрочем, если вспомнить стандарт, то окажется, что в любом месте, где можно написать пробел, можно написать и комментарий:
while /* комментарий */ (условное выражение)
	оператор
или даже так:
while
// комментарий
(условное выражение)
	оператор
В любом случае, сразу после инструкции while следует ноль или больше пробельных литер, либо комментарии, и затем условное выражение в скобках. Владея этой информацией, архиватор мог бы не хранить круглые скобки.
Эти рассуждения правдоподобны.
Предположим, что вы решили написать такой архиватор. Действительно ли это возможно? Есть ли другие способы записи инструкции while, не описанные выше? 

#### Обсуждение

Не буду вас долго мучить, вот программка:
while
#include "foo.h"
{
	. . .
}
Файл foo.h может выглядеть так:
(условное выражение)
Именно это и ответил мне Булат на все мои выкладки.
Дима Борток предложил другое решение этой задачи:
#define condition (x < 3)
while condition
{
	. . .
}
#include

#### Задача

Задача похожа на предыдущую. Возможны ли другие записи директивы #include, кроме приведённых?
#include "foo.h"
#include <bar>

#### Обсуждение

Конечно, и здесь не обошлось без макроопределений:
#ifdef WIN
	#define IO "winio.h"
#else
	#define IO <stdio.h>
#endif

#include IO
Интересно, что пример подобного использования не описан в K&R, тем не менее, он присутствует в «Рабочем проекте» комитета X3J11. Параметризация включаемых файлов иногда необходима, а такой метод не вносит дополнительной путаницы и разрешен многими существующими компиляторами, поэтому он включен в стандарт ANSI.
for

#### Задача
Оптимизируйте по скорости следующий код:
int i;
for(i = 0; i < 10; i++);
Обсуждение
Это — задачка-шутка (я действительно не понимаю смысл оптимизации пустого цикла). Она имеет не очень прямое отношение к Си и приведена здесь просто для разрядки. Ответ таков:
int i = 10;
Макроопределения
Задача
Здесь нет традиционного коварного вопроса. Вместо этого обсуждается одно тонкое место в макроопределениях, о котором, обычно, не упоминают (в действительности, я уже встречал описание этой тонкости в литературе, но на момент написания статьи упоминаний о ней не было — позднее примечание 2006г.)
В языке Паскаль существует строгое, но сложное правило расстановки точки с запятой (её нельзя ставить перед else и можно не ставить перед end). В языке Си с этим несколько проще, поскольку точку с запятой нужно ставить всегда, кроме составных операторов, заключённых в фигурные скобки.
Да?
Обсуждение
/* Переменные a и b обмениваются значениями... */
#define swap(a,b) { a = a - b; b = a + b; a = b - a; }

if(a > b)
	swap(a, b);
else
	a++, b++;
Этот кусок, кода не будет даже компилироваться, так как после обработки препроцессором приобретает следующий вид:
if(a > b)
	{ a = a - b; b = a + b; a = b - a; };
else
	a++, b++;
Если вы заметили, после закрывающей фигурной скобки стоит точка с запятой. Это означает, что между if и else находится два оператора: один — составной, ограниченный фигурными скобками, а другой — пустой, завершающийся точкой с запятой. Такое использование if не соответствует синтаксису языка Си и компилятор выдаст в этом месте ошибку.
В результате оказывается, что здесь после swap ставить точку с запятой не надо. Можно было бы в очередной раз посетовать на препроцессор, однако, существует способ обойти эту проблему. Определение swap должно быть записано так:
/* Переменные a и b обмениваются значениями... */
#define swap(a,b) do { a = a - b; b = a + b; a = b - a; } while(false)

if(a > b)
	swap(a, b);
else
	a++, b++;
Не правда ли, шикарное решение?
Макроопределения и шаблоны
Задача
Ниже приведён пример совместного использования макроопределения и шаблона. Будет ли работать такая конструкция?
#define isPositive(value1, value2) (value1 > 0)?(value2):(0)

template<int N, int M> int sum() { return N + M; }

. . .

std::cout << isPositive(sum<2, 3>(), 10);
Обсуждение
Такая конструкция не будет даже компилироваться. Компилятор выдаст ошибку о неверном числе параметров макроопределения. Препроцессор не понимает, что sum<2, 3>() является неделимой синтаксической конструкцией, и интерпретирует запятую, как разделитель параметров макроопределения. Так происходит потому, что угловые скобки в Си++ имеют двойной смысл, и для того, чтобы правильно разобрать выражение foo<const1, const2>(var1), необходимо иметь информацию о том, что foo является шаблоном. Этой информацией владеет компилятор, а у препроцессора её нет.
Обращу особое внимание, что foo<const1, const2>(var1) является синтаксически корректной конструкцией в Си и Си++, поскольку в данном случае мы имеем два выражения foo<const1 и const2>(var1), разделённые оператором «запятая».
Обойти проблему можно, поскольку круглые скобки воспринимаются препроцессором правильно (он не может судить о типе своих операндов, но в состоянии определять парность скобок). Эта строка будет компилироваться корректно:
std::cout << isPositive((sum<2, 3>()), 10);
Инкапсуляция
Задача
Теоретически, имея описание класса в заголовочном файле, мы можем обращаться к закрытым (private) членам по их смещению относительно начала класса:
foo.h:
class Foo
{
private:
    int a;
    int b;
};

. . .

Foo foo;
int *values = (int *)&foo;

values[0] = 1; // равносильно foo.a = 1;
values[1] = 2; // равносильно foo.b = 2;
Оставим сейчас в стороне вопрос о том, насколько это корректно с точки зрения принципов ООП, и подойдём к задаче исследовательски. Предложенный способ приводит к непереносимости, поскольку члены a и b могут выравниваться в классе не так, как это предполагаем мы, кроме того, если класс содержит виртуальные функции, в его начале хранится указатель на таблицу виртуальных функции. Мы можем решить эту задачу в принципе за счёт некоторых коэффициентов, но, к сожалению, они будут меняться от класса к классу и от компилятора к компилятору.
Существует ли возможность реализовать переносимый код в данном случае?
Обсуждение
Да, существует. Наиболее простой способ — воспользоваться препроцессором:
#define private public
#include "foo.h"

Foo foo;
foo.a = 1;
foo.b = 2;
Массивы
Задача
Предположим, вы переходите на Си с Паскаля и вместо непривычной инструкции a[i][j] пишите привычную a[i, j], например, в таком контексте:
printf("next = %d\n", a[i, j]);
Как на это прореагирует компилятор?
Обсуждение
Никак. В Си есть редко используемый (поэтому о нем так часто и забывают) оператор запятая «,». Фактически, этот код будет рассматриваться как
printf("next = %d\n", a[j]);
Компилятор мог бы обнаружить ошибку, если бы использование a[j] вместо a[i][j] приводило к несоответствию типов, но при вызове printf этого не происходит (см. подробности в K&R).
Кодогенерация
Задача
Какие в Си есть способы вывести на экран 100 (1000, 1 000 000) строк "Hello, world!\n", не используя цикл и рекурсию?
Обсуждение
И снова эта задача не на сметливость, а на знание тонких мест в Си и Си++. Первое решение задачи связано с использованием макроопределений.
#define DO_10_TIMES(x) { x; x; x; x; x; x; x; x; x; x; }
#define DO_100_TIMES(x) DO_10_TIMES(DO_10_TIMES(x))

void main(void)
{
	DO_100_TIMES(std::cout << "Hello, world!\n");
}
Таким образом можно организовать генерацию повторяющегося кода.
Во втором решении мы воспользуемся тем, что при создании массива объектов, для каждого объекта вызывается конструктор. Следующий код будет делать то, что нам нужно, без явного использования цикла:
class Foo
{
public:
	Foo() { std::cout << "Hello, world!\n"; }
};

void main(void)
{
	Foo foos[100];
}
Поскольку автоматически вызывается не только конструктор, но и деструктор, мы можем уменьшить размер нашего массива вдвое:
class Foo
{
public:
	Foo() { std::cout << "Hello, world!\n"; }
	~Foo() { std::cout << "Hello, world!\n"; }
};

void main(void)
{
	Foo foos[50];
}
Строго говоря, эти два примера не являются кодогенерацией, тем не менее, они удачно демонстрируют возможности Си++.
Однако примеры с повторяющимся кодом не так интересны. Ниже приведён код, в котором с помощью шаблонов осуществляется кодогенерация для вычисления чисел Фибоначчи:
template<int N>
class Fibonacci
{
public:
	inline static int getValue(void)
	{
		return Fibonacci<N - 1>::getValue() + Fibonacci<N - 2>::getValue();
	}
};

template<> 
class Fibonacci<1>
{
public:
	inline static int getValue(void)
	{
		return 1;
	}
};

template<>
class Fibonacci<2>
{
public:
	inline static int getValue(void)
	{
		return 1;
	}
};

. . .

int fibonacci10 = Fibonaccy<10>::getValue();
Особо интересным в данном случае является то, что компилятор осуществляет все вычисления на стадии компиляции. Поскольку мы оформили код в виде встраиваемых (inline) функций, у компилятора есть возможность развернуть их вызовы в константное выражение и сразу его вычислить.
Наша задача с помощью шаблонов может быть решена, например, так:
template<int N>
inline void printHelloWorld()
{
    printHelloWorld<N/10>();
    printHelloWorld<N/10>();
    printHelloWorld<N/10>();
    printHelloWorld<N/10>();
    printHelloWorld<N/10>();
    printHelloWorld<N/10>();
    printHelloWorld<N/10>();
    printHelloWorld<N/10>();
    printHelloWorld<N/10>();
    printHelloWorld<N/10>();
}

template<>
inline void printHelloWorld<1>()
{
    std::cout << "Hello, World!\n";
}

. . .

printHelloWorld<1000>();
